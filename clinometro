# immportamos las bibliotecas pygame y math
import pygame
import math
import os # Importar el módulo os
import serial # Importación corregida
import json # Para configuración persistente
from serial.tools.list_ports import comports # Para detectar puertos
from pygame.locals import * # Asegurar que locals esté después de pygame

# Importaciones adicionales para logging y Thingspeak
import requests
import csv
from datetime import datetime
import time # time ya estaba importado indirectamente, pero mejor explicitarlo si se usa time.time()

# Definimos algunos colores base primero
NEGRO = (0, 0, 0) 
BLANCO = (255, 255, 255) 
VERDE = (0, 255, 0) 
ROJO = (255, 0, 0) 
AZUL = (0, 0, 255)

# Constantes globales tempranas
ALTURA_BARRA_HERRAMIENTAS = 30


# --- CONFIGURACIÓN PARA LOGGING Y THINGSPEAK ---
API_KEY_THINGSPEAK = "5TRR6EXF6N5CZF54"  # Clave de escritura para ThingSpeak
THINGSPEAK_URL = "https://api.thingspeak.com/update"
CSV_FILENAME = "nmea_log.csv"
INTERVALO_ENVIO_DATOS_S = 15 # Intervalo para guardar en CSV y enviar a ThingSpeak (en segundos)
INTERVALO_REPETICION_ALARMA_ROLL_S = 5 # Intervalo para repetir el sonido de alarma de ROLL si la condición persiste
INTERVALO_REPETICION_ALARMA_PITCH_S = 5   # Intervalo para repetir el sonido de alarma de PITCH si la condición persiste

# Nombre del archivo de configuración para puerto serial (existente)
ARCHIVO_CONFIG_SERIAL = "config_serial.json"

# Variables para la configuración de alarmas (definidas globalmente ANTES de su uso)
ARCHIVO_CONFIG_ALARMA = "config_alarma.json"
# Formato interno para la lógica de alarma (sigue usando 4 valores)
valores_alarma = {
    "max_pitch_pos": "15", 
    "min_pitch_neg": "-15",
    "max_roll_pos": "15",
    "min_roll_neg": "-15"
}
# Nuevo diccionario para los valores de la UI de alarma simplificada
valores_ui_input_alarma = {"pitch": "15", "roll": "15"}


lista_puertos_detectados = [] # Para almacenar los puertos detectados

# Variables para reconexión automática
ultimo_intento_reconeccion_tiempo = 0
INTERVALO_RECONECCION_MS = 5000 # 5 segundos

# Variables para el mensaje "NO HAY DATOS"
ultima_vez_datos_recibidos = 0 # Se inicializará correctamente después de pygame.init()
UMBRAL_SIN_DATOS_MS = 3000 # 3 segundos

# Variables globales para datos NMEA destinados a ThingSpeak/CSV
ts_pitch_float = 0.0; ts_roll_float = 0.0; ts_lat_decimal = 0.0; ts_lon_decimal = 0.0
ts_speed_float = 0.0; ts_heading_float = 0.0; ts_timestamp_str = "N/A"

ultima_vez_envio_datos = 0 
alarma_roll_babor_activa = False; alarma_roll_estribor_activa = False
ultima_reproduccion_alarma_babor_tiempo = 0.0; ultima_reproduccion_alarma_estribor_tiempo = 0.0
alarma_pitch_sentado_activa = False; alarma_pitch_encabuzado_activa = False
ultima_reproduccion_alarma_sentado_tiempo = 0.0; ultima_reproduccion_alarma_encabuzado_tiempo = 0.0
sonido_alarma_actualmente_reproduciendo = None; tiempo_ultimo_sonido_iniciado = 0.0       
INDICE_PROXIMA_ALARMA_A_SONAR = 0; PAUSA_ENTRE_SONIDOS_ALTERNADOS_S = 1.0    

def cargar_configuracion_serial():
    try:
        with open(ARCHIVO_CONFIG_SERIAL, 'r') as f:
            config = json.load(f)
        return config.get('puerto', 'COM9'), int(config.get('baudios', 9600))
    except (FileNotFoundError, json.JSONDecodeError, ValueError):
        return 'COM9', 9600

def guardar_configuracion_serial(puerto, baudios):
    print("DEBUG: Intentando guardar configuración...") 
    config = {'puerto': puerto, 'baudios': int(baudios)}
    try:
        with open(ARCHIVO_CONFIG_SERIAL, 'w') as f: json.dump(config, f, indent=4)
        print(f"DEBUG: Configuración guardada exitosamente en {ARCHIVO_CONFIG_SERIAL}") 
        return True
    except IOError as e:
        print(f"ERROR CRÍTICO: No se pudo guardar la configuración en {ARCHIVO_CONFIG_SERIAL}. Error: {e}") 
        return False
    except Exception as e_gen:
        print(f"ERROR CRÍTICO INESPERADO al guardar configuración: {e_gen}") 
        return False

def cargar_configuracion_alarma():
    global valores_alarma, valores_ui_input_alarma
    try:
        with open(ARCHIVO_CONFIG_ALARMA, 'r') as f: config = json.load(f)
        valores_alarma["max_pitch_pos"] = str(config.get('max_pitch_pos', "15"))
        valores_alarma["min_pitch_neg"] = str(config.get('min_pitch_neg', "-15"))
        valores_alarma["max_roll_pos"] = str(config.get('max_roll_pos', "15"))
        valores_alarma["min_roll_neg"] = str(config.get('min_roll_neg', "-15"))
        try: valores_ui_input_alarma["pitch"] = str(abs(int(float(valores_alarma["max_pitch_pos"]))))
        except ValueError: valores_ui_input_alarma["pitch"] = "15"
        try: valores_ui_input_alarma["roll"] = str(abs(int(float(valores_alarma["max_roll_pos"]))))
        except ValueError: valores_ui_input_alarma["roll"] = "15"
    except: 
        valores_alarma = {"max_pitch_pos": "15", "min_pitch_neg": "-15", "max_roll_pos": "15", "min_roll_neg": "-15"}
        valores_ui_input_alarma = {"pitch": "15", "roll": "15"}

def guardar_configuracion_alarma(): 
    global valores_alarma, valores_ui_input_alarma
    try:
        pitch_val_ui = int(valores_ui_input_alarma["pitch"])
        roll_val_ui = int(valores_ui_input_alarma["roll"])
        if not (5 <= pitch_val_ui <= 30): pitch_val_ui = 15 
        if not (5 <= roll_val_ui <= 30): roll_val_ui = 15 
        valores_ui_input_alarma["pitch"] = str(pitch_val_ui) # Actualizar UI con valor validado/corregido
        valores_ui_input_alarma["roll"] = str(roll_val_ui)   # Actualizar UI con valor validado/corregido
        valores_alarma["max_pitch_pos"] = str(pitch_val_ui)
        valores_alarma["min_pitch_neg"] = str(-pitch_val_ui)
        valores_alarma["max_roll_pos"] = str(roll_val_ui)
        valores_alarma["min_roll_neg"] = str(-roll_val_ui)
        with open(ARCHIVO_CONFIG_ALARMA, 'w') as f: json.dump(valores_alarma, f, indent=4) 
        print(f"DEBUG: Configuración de alarma guardada (expandida): {valores_alarma}")
        return True
    except (IOError, ValueError) as e:
        print(f"Error al guardar la configuración de alarma: {e}")
        return False

def obtener_estado_alarma_actual():
    mensajes_alarma = []
    if alarma_roll_babor_activa: mensajes_alarma.append("ROLL BABOR")
    elif alarma_roll_estribor_activa: mensajes_alarma.append("ROLL ESTRIBOR")
    if alarma_pitch_sentado_activa: mensajes_alarma.append("PITCH SENTADO")
    elif alarma_pitch_encabuzado_activa: mensajes_alarma.append("PITCH ENCABUZADO")
    return "ALARMA " + " Y ".join(mensajes_alarma) if mensajes_alarma else "SIN ALARMA"

def init_csv():
    try:
        with open(CSV_FILENAME, 'x', newline='') as f: writer = csv.writer(f); writer.writerow(["FechaHora", "Pitch", "Roll", "Latitud", "Longitud", "Velocidad", "Rumbo"])
    except FileExistsError: pass

def guardar_csv():
    with open(CSV_FILENAME, 'a', newline='') as f: writer = csv.writer(f); writer.writerow([ts_timestamp_str, ts_pitch_float, ts_roll_float, ts_lat_decimal, ts_lon_decimal, ts_speed_float, ts_heading_float])

def enviar_thingspeak():
    payload = {'api_key': API_KEY_THINGSPEAK, 'field1': ts_pitch_float, 'field2': ts_roll_float, 'field3': ts_lat_decimal, 'field4': ts_lon_decimal, 'field5': ts_speed_float, 'field6': ts_heading_float, 'field7': ts_timestamp_str}
    payload['field8'] = obtener_estado_alarma_actual()
    try:
        r = requests.get(THINGSPEAK_URL, params=payload) 
        if r.status_code == 200: print(f"[OK] Datos enviados a ThingSpeak: {ts_timestamp_str}")
        else: print(f"[ERROR] Respuesta ThingSpeak: {r.status_code} - {r.text}")
    except Exception as e: print(f"[ERROR] Conexión ThingSpeak: {e}")

def convertir_coord(coord_str, direccion, is_longitude=False):
    try:
        idx_punto = coord_str.find('.');
        if idx_punto == -1 or not coord_str or not direccion : return 0.0 
        min_start_index = idx_punto - 2
        if min_start_index < 0: return 0.0
        grados_str = coord_str[:min_start_index]; minutos_str = coord_str[min_start_index:] 
        if not grados_str: return 0.0
        grados = int(grados_str); minutos = float(minutos_str)
        decimal = grados + minutos / 60.0
        if direccion in ['S', 'W']: decimal *= -1
        return round(decimal, 6)
    except: return 0.0 

pygame.init(); pygame.mixer.init() 
script_dir = os.path.dirname(os.path.abspath(__file__)) 
try:
    sonido_alarma_babor = pygame.mixer.Sound(os.path.join(script_dir, "ALARMA_BABOR.mp3"))
    sonido_alarma_estribor = pygame.mixer.Sound(os.path.join(script_dir, "ALARMA_ESTRIBOR.mp3"))
    sonido_alarma_sentado = pygame.mixer.Sound(os.path.join(script_dir, "alarma_sentado.mp3"))
    sonido_alarma_encabuzado = pygame.mixer.Sound(os.path.join(script_dir, "alarma_encabuzado.mp3"))
except pygame.error as e:
    print(f"Error al cargar archivos de sonido MP3: {e}")
    sonido_alarma_babor = None; sonido_alarma_estribor = None; sonido_alarma_sentado = None; sonido_alarma_encabuzado = None

ultima_vez_datos_recibidos = pygame.time.get_ticks() 
puerto, baudios = cargar_configuracion_serial()
cargar_configuracion_alarma() 
ser = None; serial_port_available = True
mostrar_ventana_config_serial = False; mostrar_ventana_acerca_de = False; mostrar_ventana_alarma = False
input_alarma_activo = None 
rect_ventana_alarma = pygame.Rect(250, 100, 380, 230) 
rect_input_pitch_alarma = None; rect_input_roll_alarma = None 
rect_boton_guardar_alarma = None; rect_boton_salir_alarma = None; rect_boton_cerrar_acerca_de = None
input_puerto_str = str(puerto) 
lista_baudios_seleccionables = sorted([4800, 9600, 19200, 38400, 57600, 115200]) 
try: input_baudios_idx = lista_baudios_seleccionables.index(baudios)
except ValueError: input_baudios_idx = 0 

dimensiones = [1060, 430] 

# --- Ventana Configuración Puerto Serie ---
ventana_config_width = 300 # Reducido a la mitad
ventana_config_height = 400 # Aumentada para acomodar desplazamiento de baudios
ventana_config_x = (dimensiones[0] - ventana_config_width) // 2
ventana_config_y = (dimensiones[1] - ventana_config_height) // 2
rect_ventana_config = pygame.Rect(ventana_config_x, ventana_config_y, ventana_config_width, ventana_config_height) 

COLOR_VENTANA_FONDO = (144, 238, 144); COLOR_TEXTO_NORMAL = NEGRO; COLOR_BORDE_VENTANA = (170, 170, 170) 
COLOR_BORDE_VENTANA_CLARO = (220, 220, 220); COLOR_BORDE_VENTANA_OSCURO = (100, 100, 100)
COLOR_BARRA_HERRAMIENTAS_FONDO = (220, 220, 220); COLOR_BARRA_HERRAMIENTAS_BORDE = (180, 180, 180); COLOR_ITEM_MENU_TEXTO = NEGRO
COLOR_BOTON_FONDO = (225, 225, 225); COLOR_BOTON_BORDE = (150, 150, 150) 
COLOR_BOTON_FONDO_3D = (210, 210, 210); COLOR_BOTON_BORDE_CLARO_3D = (230, 230, 230); COLOR_BOTON_BORDE_OSCURO_3D = (130, 130, 130)
COLOR_INPUT_FONDO = BLANCO; COLOR_INPUT_BORDE = (120, 120, 120) 
COLOR_INPUT_BORDE_CLARO_3D = (200, 200, 200); COLOR_INPUT_BORDE_OSCURO_3D = (80, 80, 80)   
COLOR_DROPDOWN_FONDO = (250, 250, 250); COLOR_DROPDOWN_BORDE = (100, 100, 100); COLOR_SELECCION_DROPDOWN = (200, 220, 255) 
COLOR_CAJA_DATOS_FONDO = BLANCO; COLOR_CAJA_DATOS_BORDE = (120, 120, 120); COLOR_CAJA_DATOS_TEXTO = NEGRO 
input_puerto_activo = False; puerto_dropdown_activo = False; baudios_dropdown_activo = False 

input_elements_top_offset_config = 50 # Y inicial para el primer input en config puerto
input_elements_height_config = 30
label_width_config = 70  # Ancho para etiquetas "Puerto:", "Baudios:"
padding_interno_config = 10 # Espacio entre etiqueta e input, y entre input y borde ventana
input_width_config = ventana_config_width - label_width_config - padding_interno_config * 3 # Ajustar ancho del input

rect_input_puerto_config = pygame.Rect(rect_ventana_config.left + padding_interno_config + label_width_config + padding_interno_config, 
                                     rect_ventana_config.top + input_elements_top_offset_config, 
                                     input_width_config, input_elements_height_config)
y_pos_baudios = rect_input_puerto_config.bottom + 15 + 50 # 15 padding original + 50px de desplazamiento
rect_input_baudios_display_config = pygame.Rect(rect_ventana_config.left + padding_interno_config + label_width_config + padding_interno_config, 
                                              y_pos_baudios, 
                                              input_width_config, input_elements_height_config)
rect_lista_puertos_desplegable = None; lista_rects_items_puerto = [] 
rect_lista_baudios_desplegable = None; lista_rects_items_baudios = []

button_config_width = ventana_config_width - 40 # Botón más ancho
button_config_height = 40
rect_boton_guardar_config = pygame.Rect(rect_ventana_config.centerx - button_config_width // 2, 
                                      rect_ventana_config.bottom - button_config_height - 20, 
                                      button_config_width, button_config_height)
rect_boton_cerrar_config = pygame.Rect(rect_ventana_config.right - 35, rect_ventana_config.top + 5, 30, 30) 

try: 
    ser = serial.Serial(puerto, baudios, timeout=1) 
    print(f"Puerto serial {puerto} abierto con {baudios} baudios.")
except serial.SerialException as e: 
    print(f"Error opening serial port {puerto} with {baudios} baud: {e}"); serial_port_available = False
except Exception as e: 
    print(f"An unexpected error occurred opening serial port: {e}"); serial_port_available = False

latitude_str = "N/A"; longitude_str = "N/A"; speed_str = "N/A"; heading_str = "N/A"
att_heading_str = "N/A"; att_pitch_str = "N/A"; att_roll_str = "N/A"

def parse_pfec_gpatt(sentence): # ... (sin cambios)
    global att_heading_str, att_pitch_str, att_roll_str, ultima_vez_datos_recibidos, ts_pitch_float, ts_roll_float
    try:
        parts = sentence.split(',')
        if len(parts) >= 5 and parts[1] == "GPatt":
            att_heading_str = parts[2] if parts[2] else "N/A"
            raw_pitch = parts[3]; att_pitch_str = raw_pitch if raw_pitch else "N/A"
            try: ts_pitch_float = float(raw_pitch)
            except: ts_pitch_float = 0.0 
            raw_roll_part = parts[4].split('*')[0]; att_roll_str = raw_roll_part if raw_roll_part else "N/A"
            try: ts_roll_float = float(raw_roll_part)
            except: ts_roll_float = 0.0
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except: pass
def _actualizar_coordenadas_ui_y_ts(lat_raw_val, lat_dir, lon_raw_val, lon_dir): # ... (sin cambios)
    global latitude_str, longitude_str, ts_lat_decimal, ts_lon_decimal
    latitude_str_temp, longitude_str_temp = "N/A", "N/A"; ts_lat_decimal_temp, ts_lon_decimal_temp = 0.0, 0.0
    if lat_raw_val and lat_dir and len(lat_raw_val) >=2:
        lat_deg_ui = lat_raw_val[:2]; lat_min_full_ui = lat_raw_val[2:]
        try: lat_min_formatted_ui = f"{float(lat_min_full_ui):.3f}"
        except: lat_min_formatted_ui = lat_min_full_ui 
        latitude_str_temp = f"{lat_deg_ui}° {lat_min_formatted_ui}' {lat_dir}"; ts_lat_decimal_temp = convertir_coord(lat_raw_val, lat_dir, is_longitude=False)
    if lon_raw_val and lon_dir and len(lon_raw_val) >=3:
        lon_parts_ui = lon_raw_val.split('.')[0]; deg_chars = 0
        if len(lon_parts_ui) >= 5: deg_chars = 3 
        elif len(lon_parts_ui) >= 4: deg_chars = 2 
        elif len(lon_parts_ui) >= 3: deg_chars = 1 
        if deg_chars > 0:
            lon_deg_ui = lon_raw_val[:deg_chars]; lon_min_full_ui = lon_raw_val[deg_chars:]
            try: lon_min_formatted_ui = f"{float(lon_min_full_ui):.3f}"
            except: lon_min_formatted_ui = lon_min_full_ui
            longitude_str_temp = f"{lon_deg_ui}° {lon_min_formatted_ui}' {lon_dir}"; ts_lon_decimal_temp = convertir_coord(lon_raw_val, lon_dir, is_longitude=True)
    latitude_str, longitude_str = latitude_str_temp, longitude_str_temp; ts_lat_decimal, ts_lon_decimal = ts_lat_decimal_temp, ts_lon_decimal_temp
def parse_gga(sentence): # ... (sin cambios)
    global ultima_vez_datos_recibidos
    try:
        parts = sentence.split(',')
        if len(parts) > 5 and parts[2] and parts[3] and parts[4] and parts[5]:
            _actualizar_coordenadas_ui_y_ts(parts[2], parts[3], parts[4], parts[5]); ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except: pass
def parse_rmc(sentence): # ... (sin cambios)
    global ultima_vez_datos_recibidos
    try:
        parts = sentence.split(',')
        if len(parts) > 6 and parts[3] and parts[4] and parts[5] and parts[6]: 
            _actualizar_coordenadas_ui_y_ts(parts[3], parts[4], parts[5], parts[6]); ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except: pass
def parse_gll(sentence): # ... (sin cambios)
    global ultima_vez_datos_recibidos
    try: 
        parts = sentence.split(',') 
        if len(parts) > 4 and parts[1] and parts[2] and parts[3] and parts[4]: 
            _actualizar_coordenadas_ui_y_ts(parts[1], parts[2], parts[3], parts[4]); ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except: pass
def parse_vtg(sentence): # ... (sin cambios)
    global speed_str, ultima_vez_datos_recibidos, ts_speed_float
    try: 
        parts = sentence.split(','); speed_val_str_ui = "N/A"; temp_speed_float = 0.0
        if len(parts) > 5 and parts[5]: 
            speed_val_str_ui = parts[5] 
            try: temp_speed_float = float(speed_val_str_ui)
            except: temp_speed_float = 0.0
        elif len(parts) > 7 and parts[7]: 
            speed_kmh_str = parts[7]
            try: speed_kmh = float(speed_kmh_str); temp_speed_float = round(speed_kmh / 1.852, 1); speed_val_str_ui = str(temp_speed_float)
            except: pass
        if speed_val_str_ui != "N/A": speed_str = f"{speed_val_str_ui} Kt"; ts_speed_float = temp_speed_float; ultima_vez_datos_recibidos = pygame.time.get_ticks()
        else: speed_str = "N/A Kt"; ts_speed_float = 0.0
    except: pass
def parse_hdt(sentence): # ... (sin cambios)
    global heading_str, ultima_vez_datos_recibidos, ts_heading_float
    try: 
        parts = sentence.split(',') 
        if len(parts) > 1 and parts[1]: 
            heading_val_str = parts[1]
            try: heading_val_float = float(heading_val_str); heading_str = f"{heading_val_float:.0f}°"; ts_heading_float = heading_val_float      
            except: heading_str = f"{heading_val_str}°"; ts_heading_float = 0.0 
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except: pass
def parse_hdg(sentence): # ... (sin cambios)
    global heading_str, ultima_vez_datos_recibidos, ts_heading_float
    try: 
        parts = sentence.split(',') 
        if len(parts) > 1 and parts[1]: 
            heading_val_str = parts[1] 
            try: heading_val_float = float(heading_val_str); heading_str = f"{heading_val_float:.0f}°"; ts_heading_float = heading_val_float      
            except: heading_str = f"{heading_val_str}°"; ts_heading_float = 0.0
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except: pass
def parse_gpzda(sentence): # ... (sin cambios)
    global ts_timestamp_str 
    try:
        parts = sentence.split(',')
        if len(parts) >= 5: 
            time_utc_str = parts[1]; day_str = parts[2]; month_str = parts[3]; year_str = parts[4]
            if '.' in time_utc_str: time_utc_str = time_utc_str.split('.')[0]
            if len(time_utc_str) == 6 and day_str and month_str and year_str and len(year_str) == 4:
                h,m,s = time_utc_str[0:2], time_utc_str[2:4], time_utc_str[4:6]
                ts_timestamp_str = f"{year_str}-{month_str.zfill(2)}-{day_str.zfill(2)} {h}:{m}:{s}"
    except: pass 

screen = pygame.display.set_mode(dimensiones); pygame.display.set_caption("Lalito") 
nuevo_ancho_area_izquierda = 750 
area_izquierda_rect = pygame.Rect(10, ALTURA_BARRA_HERRAMIENTAS + 10, nuevo_ancho_area_izquierda, dimensiones[1] - (ALTURA_BARRA_HERRAMIENTAS + 20)) 
radio_circulo_img = 78 * 2; margen_superior_circulos = 20 
centro_y_circulos = area_izquierda_rect.top + radio_circulo_img + margen_superior_circulos 
centro_x_circulo1 = 10 + radio_circulo_img + 50; centro_x_circulo2 = centro_x_circulo1 + (2 * radio_circulo_img) + 50
LONGITUD_MARCA_GRADO = 16; GROSOR_MARCA_GRADO = 3; COLOR_MARCA_GRADO = BLANCO; COLOR_ETIQUETA_GRADO = BLANCO 
RADIO_INICIO_MARCAS = radio_circulo_img; RADIO_FIN_MARCAS = radio_circulo_img + LONGITUD_MARCA_GRADO
OFFSET_TEXTO_ETIQUETA = 20; RADIO_POSICION_TEXTO_ETIQUETA = RADIO_FIN_MARCAS + OFFSET_TEXTO_ETIQUETA
ANGULOS_MARCAS_ETIQUETAS_DEF = {"0_der": (0, "0"), "0_izq": (180, "0"), "sup_mas_30": (-120, "+30"), "sup_menos_30": (-60, "-30")}
LONGITUD_FLECHA_DIR = 20; ANCHO_FLECHA_DIR = 12; OFFSET_FLECHA_TEXTO = 10; OFFSET_LETRA_ROLL_Y = 10; COLOR_LETRA_ROLL = BLANCO 
script_dir = os.path.dirname(os.path.abspath(__file__))
ruta_imagen_fondo = os.path.join(script_dir, "mar.jpg")
try:
    imagen_fondo_original = pygame.image.load(ruta_imagen_fondo) 
    imagen_fondo_escalada = pygame.transform.scale(imagen_fondo_original, dimensiones); imagen_fondo_escalada = imagen_fondo_escalada.convert() 
except: imagen_fondo_escalada = None 
pitch_image_base_grande = None 
try:
    pitch_image_surface_original_temp = pygame.image.load(os.path.join(script_dir, "pitch.png"))
    lado_pitch_deseado_grande = int((2 * radio_circulo_img) + 2)                                                                
    pitch_image_base_grande = pygame.transform.smoothscale(pitch_image_surface_original_temp, (lado_pitch_deseado_grande, lado_pitch_deseado_grande)).convert_alpha()
except: pitch_image_base_grande = None
roll_image_base_grande = None
try:
    roll_image_surface_original_temp = pygame.image.load(os.path.join(script_dir, "roll.png"))
    lado_img_deseado_grande = int((2 * radio_circulo_img) + 2)                                                               
    roll_image_base_grande = pygame.transform.smoothscale(roll_image_surface_original_temp, (lado_img_deseado_grande, lado_img_deseado_grande)).convert_alpha()
except: roll_image_base_grande = None
font = pygame.font.Font(None, 24); font_bar_herramientas = pygame.font.Font(None, 22) 
font_datos_grandes = pygame.font.Font(None, 50); font_circulos_textos = pygame.font.Font(None, 72) 
texto_latitud_lon_titulo = "LAT / LON"; texto_actitud_titulo = "CABECEO" 
reloj = pygame.time.Clock(); rect_barra_herramientas = pygame.Rect(0, 0, dimensiones[0], ALTURA_BARRA_HERRAMIENTAS)
opciones_menu_barra = ["CONFIG. PUERTO", "CONFIG. ALARM", "ACERCA DE"]
rects_opciones_menu_barra = []; padding_menu_x = 15; espacio_entre_menus = 10 
hecho = False; init_csv(); ultima_vez_envio_datos = time.time() 
print(f"DEBUG: COLOR_INPUT_BORDE justo antes del bucle principal: {globals().get('COLOR_INPUT_BORDE')}")

while not hecho: # ... (resto del bucle principal sin cambios hasta la sección de dibujado de ventanas modales) ...
    for evento in pygame.event.get():  
        if evento.type == pygame.QUIT: hecho = True               
        if evento.type == pygame.MOUSEBUTTONDOWN:
            if evento.button == 1: 
                if not mostrar_ventana_config_serial and not mostrar_ventana_acerca_de and not mostrar_ventana_alarma: 
                    if rects_opciones_menu_barra and len(rects_opciones_menu_barra) > 0 and rects_opciones_menu_barra[0].collidepoint(evento.pos): 
                        mostrar_ventana_config_serial = True; input_puerto_str = str(puerto) 
                        try: input_baudios_idx = lista_baudios_seleccionables.index(int(baudios))
                        except ValueError: input_baudios_idx = 0 
                        puerto_dropdown_activo = False; baudios_dropdown_activo = False; lista_puertos_detectados.clear()
                        try:
                            ports = comports()
                            if ports: [lista_puertos_detectados.append(p.device) for p in ports]
                            else: lista_puertos_detectados.append("N/A") 
                        except Exception as e_com: lista_puertos_detectados.append("Error") 
                        if puerto not in lista_puertos_detectados and lista_puertos_detectados and lista_puertos_detectados[0] not in ["N/A", "Error"]: pass 
                    elif len(rects_opciones_menu_barra) > 1 and rects_opciones_menu_barra[1].collidepoint(evento.pos): 
                        mostrar_ventana_alarma = True; input_alarma_activo = None
                        try: valores_ui_input_alarma["pitch"] = str(abs(int(float(valores_alarma["max_pitch_pos"]))))
                        except: valores_ui_input_alarma["pitch"] = "15" 
                        try: valores_ui_input_alarma["roll"] = str(abs(int(float(valores_alarma["max_roll_pos"]))))
                        except: valores_ui_input_alarma["roll"] = "15" 
                    elif len(rects_opciones_menu_barra) > 2 and rects_opciones_menu_barra[2].collidepoint(evento.pos): 
                        mostrar_ventana_acerca_de = True
                elif mostrar_ventana_config_serial: 
                    if puerto_dropdown_activo:
                        clic_en_item_puerto = False
                        for i, item_rect in enumerate(lista_rects_items_puerto):
                            if item_rect.collidepoint(evento.pos): input_puerto_str = lista_puertos_detectados[i]; puerto_dropdown_activo = False; clic_en_item_puerto = True; break
                        if not clic_en_item_puerto and not rect_input_puerto_config.collidepoint(evento.pos): puerto_dropdown_activo = False 
                    elif rect_input_puerto_config.collidepoint(evento.pos): 
                        puerto_dropdown_activo = not puerto_dropdown_activo; 
                        if puerto_dropdown_activo: baudios_dropdown_activo = False 
                    elif baudios_dropdown_activo:
                        clic_en_item_baudios = False
                        for i, item_rect in enumerate(lista_rects_items_baudios):
                            if item_rect.collidepoint(evento.pos): input_baudios_idx = i; baudios_dropdown_activo = False; clic_en_item_baudios = True; break
                        if not clic_en_item_baudios and not rect_input_baudios_display_config.collidepoint(evento.pos): baudios_dropdown_activo = False
                    elif rect_input_baudios_display_config.collidepoint(evento.pos): 
                        baudios_dropdown_activo = not baudios_dropdown_activo
                        if baudios_dropdown_activo: puerto_dropdown_activo = False 
                    elif rect_boton_cerrar_config.collidepoint(evento.pos): mostrar_ventana_config_serial = False; puerto_dropdown_activo = False; baudios_dropdown_activo = False
                    elif rect_boton_guardar_config.collidepoint(evento.pos): 
                        print("DEBUG: Botón Guardar presionado.") 
                        nuevos_baudios = lista_baudios_seleccionables[input_baudios_idx]
                        guardado_exitoso = guardar_configuracion_serial(input_puerto_str, nuevos_baudios)
                        if guardado_exitoso:
                            print("DEBUG: Guardado exitoso, procediendo a aplicar y cerrar.") 
                            puerto = input_puerto_str; baudios = nuevos_baudios
                            if ser and ser.is_open: ser.close()
                            try:
                                print(f"DEBUG: Intentando reabrir puerto {puerto} con {baudios} baudios y timeout de 2s.")
                                ser = serial.Serial(puerto, baudios, timeout=2); serial_port_available = True
                                print(f"DEBUG: Puerto {puerto} reabierto exitosamente.")
                            except serial.SerialException as e: print(f"Error reabriendo puerto serial {puerto} con {baudios} baud: {e}"); serial_port_available = False
                            except Exception as e: print(f"Error inesperado reabriendo puerto: {e}"); serial_port_available = False 
                            mostrar_ventana_config_serial = False; puerto_dropdown_activo = False; baudios_dropdown_activo = False
                        else: print("DEBUG: Fallo al guardar. La ventana de configuración permanecerá abierta.")                             
                    else: puerto_dropdown_activo = False; baudios_dropdown_activo = False 
                elif mostrar_ventana_alarma:
                    if rect_boton_salir_alarma and rect_boton_salir_alarma.collidepoint(evento.pos): mostrar_ventana_alarma = False; input_alarma_activo = None
                    elif rect_boton_guardar_alarma and rect_boton_guardar_alarma.collidepoint(evento.pos):
                        try:
                            pitch_ui_val_str = valores_ui_input_alarma["pitch"]
                            roll_ui_val_str = valores_ui_input_alarma["roll"]
                            pitch_val_to_save = int(pitch_ui_val_str) if pitch_ui_val_str else 15 # Default si está vacío
                            roll_val_to_save = int(roll_ui_val_str) if roll_ui_val_str else 15 # Default si está vacío
                            valores_ui_input_alarma["pitch"] = str(pitch_val_to_save) # Actualizar UI con valor (o default si era vacío)
                            valores_ui_input_alarma["roll"] = str(roll_val_to_save)   # Actualizar UI con valor (o default si era vacío)
                            if guardar_configuracion_alarma(): 
                                mostrar_ventana_alarma = False; input_alarma_activo = None
                                print("DEBUG: Configuración de alarma guardada y ventana cerrada.")
                            else: print("DEBUG: Error al guardar configuración de alarma. Ventana permanece abierta.")
                        except ValueError: print("DEBUG: Error de valor en inputs de alarma. No numérico.")
                    elif rect_input_pitch_alarma and rect_input_pitch_alarma.collidepoint(evento.pos): input_alarma_activo = "pitch"
                    elif rect_input_roll_alarma and rect_input_roll_alarma.collidepoint(evento.pos): input_alarma_activo = "roll"
                    else: input_alarma_activo = None
                elif mostrar_ventana_acerca_de:
                    if rect_boton_cerrar_acerca_de and rect_boton_cerrar_acerca_de.collidepoint(evento.pos): mostrar_ventana_acerca_de = False
        if evento.type == pygame.KEYDOWN:
            if mostrar_ventana_config_serial: 
                if evento.key == pygame.K_ESCAPE: mostrar_ventana_config_serial = False; puerto_dropdown_activo = False
            elif mostrar_ventana_alarma and input_alarma_activo: 
                if evento.key == pygame.K_ESCAPE: mostrar_ventana_alarma = False; input_alarma_activo = None
                elif evento.key == pygame.K_BACKSPACE: valores_ui_input_alarma[input_alarma_activo] = valores_ui_input_alarma[input_alarma_activo][:-1]
                elif evento.unicode.isdigit():
                    if len(valores_ui_input_alarma[input_alarma_activo]) < 2: valores_ui_input_alarma[input_alarma_activo] += evento.unicode
            elif mostrar_ventana_acerca_de: 
                if evento.key == pygame.K_ESCAPE: mostrar_ventana_acerca_de = False

    if not serial_port_available and not mostrar_ventana_config_serial and not mostrar_ventana_alarma and not mostrar_ventana_acerca_de: 
        ahora = pygame.time.get_ticks()
        if ahora - ultimo_intento_reconeccion_tiempo > INTERVALO_RECONECCION_MS:
            ultimo_intento_reconeccion_tiempo = ahora
            try:
                if ser and ser.is_open: ser.close()
                ser = serial.Serial(puerto, baudios, timeout=1); serial_port_available = True 
            except serial.SerialException as e_reconect: ser = None; serial_port_available = False 
            except Exception as e_reconect_general: print(f"Error inesperado reconexión: {e_reconect_general}"); ser = None; serial_port_available = False 

    if serial_port_available and ser and ser.is_open: 
        try:
            if ser.in_waiting > 0: 
                line = ser.readline().decode('ascii', errors='replace').strip()
                if line.startswith('$GPGLL') or line.startswith('$GNGLL'): parse_gll(line)
                elif line.startswith('$GPGGA') or line.startswith('$GNGGA'): parse_gga(line) 
                elif line.startswith('$GPRMC') or line.startswith('$GNRMC'): parse_rmc(line) 
                elif line.startswith('$GPVTG') or line.startswith('$GNVTG'): parse_vtg(line)
                elif line.startswith('$GPHDT') or line.startswith('$GNHDT'): parse_hdt(line)
                elif line.startswith('$GPHDG') or line.startswith('$GNHDG'): parse_hdg(line)
                elif line.startswith('$PFEC,GPatt'): parse_pfec_gpatt(line)
                elif line.startswith('$GPZDA') or line.startswith('$GNZDA'): parse_gpzda(line) 
        except serial.SerialException as se: print(f"SerialException lectura: {se}. Puerto desconectado."); ser.close(); ser = None; serial_port_available = False; ultimo_intento_reconeccion_tiempo = pygame.time.get_ticks() 
        except Exception as e: pass
    
    if time.time() - ultima_vez_envio_datos >= INTERVALO_ENVIO_DATOS_S:
        if serial_port_available : 
            estado_alarma_para_print = obtener_estado_alarma_actual() 
            print(f"--- Guardando y Enviando Datos ({time.strftime('%Y-%m-%d %H:%M:%S')}) ---")
            print(f"Valores: P:{ts_pitch_float}, R:{ts_roll_float}, Lat:{ts_lat_decimal}, Lon:{ts_lon_decimal}, Spd:{ts_speed_float}, Hdg:{ts_heading_float}, TS:{ts_timestamp_str}, Alarma: {estado_alarma_para_print}")
            guardar_csv(); enviar_thingspeak(); print("---------------------------------------------------\n")
        ultima_vez_envio_datos = time.time()

    ahora = time.time() 
    if att_roll_str != "N/A" and valores_alarma:
        try:
            current_roll_float = ts_roll_float
            umbral_min_roll = int(valores_alarma["min_roll_neg"]); umbral_max_roll = int(valores_alarma["max_roll_pos"])
            if current_roll_float < umbral_min_roll: 
                if not alarma_roll_babor_activa: pass
                alarma_roll_babor_activa = True
            else: 
                if alarma_roll_babor_activa: alarma_roll_babor_activa = False; ultima_reproduccion_alarma_babor_tiempo = 0 
            if current_roll_float > umbral_max_roll: 
                if not alarma_roll_estribor_activa: pass
                alarma_roll_estribor_activa = True
            else: 
                if alarma_roll_estribor_activa: alarma_roll_estribor_activa = False; ultima_reproduccion_alarma_estribor_tiempo = 0
        except (ValueError, KeyError) as e: alarma_roll_babor_activa = False; alarma_roll_estribor_activa = False
            
    if att_pitch_str != "N/A" and valores_alarma: 
        try:
            current_pitch_float = ts_pitch_float 
            umbral_min_pitch = int(valores_alarma["min_pitch_neg"]); umbral_max_pitch = int(valores_alarma["max_pitch_pos"]) 
            if current_pitch_float < umbral_min_pitch:
                if not alarma_pitch_encabuzado_activa: pass
                alarma_pitch_encabuzado_activa = True
            else: 
                if alarma_pitch_encabuzado_activa: alarma_pitch_encabuzado_activa = False; ultima_reproduccion_alarma_encabuzado_tiempo = 0 
            if current_pitch_float > umbral_max_pitch:
                if not alarma_pitch_sentado_activa: pass
                alarma_pitch_sentado_activa = True
            else: 
                if alarma_pitch_sentado_activa: alarma_pitch_sentado_activa = False; ultima_reproduccion_alarma_sentado_tiempo = 0
        except (ValueError, KeyError) as e: alarma_pitch_sentado_activa = False; alarma_pitch_encabuzado_activa = False

    alarmas_condiciones_activas_info = [] 
    if alarma_roll_babor_activa and sonido_alarma_babor: alarmas_condiciones_activas_info.append({'id': 'roll_babor', 'sonido': sonido_alarma_babor, 'tiempo_var_name': 'ultima_reproduccion_alarma_babor_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_ROLL_S, 'mensaje': f"ALARMA BABOR (Roll {ts_roll_float}°)"})
    if alarma_roll_estribor_activa and sonido_alarma_estribor: alarmas_condiciones_activas_info.append({'id': 'roll_estribor', 'sonido': sonido_alarma_estribor, 'tiempo_var_name': 'ultima_reproduccion_alarma_estribor_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_ROLL_S, 'mensaje': f"ALARMA ESTRIBOR (Roll {ts_roll_float}°)"})
    if alarma_pitch_sentado_activa and sonido_alarma_sentado: alarmas_condiciones_activas_info.append({'id': 'pitch_sentado', 'sonido': sonido_alarma_sentado, 'tiempo_var_name': 'ultima_reproduccion_alarma_sentado_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_PITCH_S, 'mensaje': f"ALARMA SENTADO (Pitch {ts_pitch_float}°)"})
    if alarma_pitch_encabuzado_activa and sonido_alarma_encabuzado: alarmas_condiciones_activas_info.append({'id': 'pitch_encabuzado', 'sonido': sonido_alarma_encabuzado, 'tiempo_var_name': 'ultima_reproduccion_alarma_encabuzado_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_PITCH_S, 'mensaje': f"ALARMA ENCABUZADO (Pitch {ts_pitch_float}°)"})
    alarmas_listas_para_sonar_info = []
    for alarma_info in alarmas_condiciones_activas_info:
        if ahora - globals()[alarma_info['tiempo_var_name']] >= alarma_info['intervalo']: alarmas_listas_para_sonar_info.append(alarma_info)
    if not alarmas_condiciones_activas_info: 
        if sonido_alarma_actualmente_reproduciendo is not None:
            sonido_alarma_actualmente_reproduciendo.stop(); sonido_alarma_actualmente_reproduciendo = None
            INDICE_PROXIMA_ALARMA_A_SONAR = 0 
            ultima_reproduccion_alarma_babor_tiempo = 0.0; ultima_reproduccion_alarma_estribor_tiempo = 0.0
            ultima_reproduccion_alarma_sentado_tiempo = 0.0; ultima_reproduccion_alarma_encabuzado_tiempo = 0.0
    elif alarmas_listas_para_sonar_info: 
        sonido_actual_ha_terminado_o_pausa_cumplida = True
        if sonido_alarma_actualmente_reproduciendo is not None:
            duracion_sonido_actual = 0
            try: duracion_sonido_actual = sonido_alarma_actualmente_reproduciendo.get_length()
            except pygame.error: sonido_alarma_actualmente_reproduciendo = None 
            if sonido_alarma_actualmente_reproduciendo is not None and (ahora < tiempo_ultimo_sonido_iniciado + duracion_sonido_actual + PAUSA_ENTRE_SONIDOS_ALTERNADOS_S):
                sonido_actual_ha_terminado_o_pausa_cumplida = False
        if sonido_actual_ha_terminado_o_pausa_cumplida:
            if INDICE_PROXIMA_ALARMA_A_SONAR >= len(alarmas_listas_para_sonar_info): INDICE_PROXIMA_ALARMA_A_SONAR = 0
            alarma_a_reproducir_info = alarmas_listas_para_sonar_info[INDICE_PROXIMA_ALARMA_A_SONAR]
            if sonido_alarma_actualmente_reproduciendo is not None and sonido_alarma_actualmente_reproduciendo != alarma_a_reproducir_info['sonido']:
                sonido_alarma_actualmente_reproduciendo.stop()
            alarma_a_reproducir_info['sonido'].play()
            sonido_alarma_actualmente_reproduciendo = alarma_a_reproducir_info['sonido']
            tiempo_ultimo_sonido_iniciado = ahora
            globals()[alarma_a_reproducir_info['tiempo_var_name']] = ahora 
            INDICE_PROXIMA_ALARMA_A_SONAR = (INDICE_PROXIMA_ALARMA_A_SONAR + 1) 

    if imagen_fondo_escalada: screen.blit(imagen_fondo_escalada, (0, 0))
    else: screen.fill(AZUL) 
    pygame.draw.rect(screen, COLOR_BARRA_HERRAMIENTAS_FONDO, rect_barra_herramientas)
    pygame.draw.rect(screen, COLOR_BARRA_HERRAMIENTAS_BORDE, rect_barra_herramientas, 1) 
    rects_opciones_menu_barra.clear(); current_x_menu_draw = padding_menu_x
    for opcion_texto in opciones_menu_barra:
        texto_surf = font_bar_herramientas.render(opcion_texto, True, COLOR_ITEM_MENU_TEXTO)
        texto_rect = texto_surf.get_rect(left=current_x_menu_draw, centery=rect_barra_herramientas.centery)
        clickable_rect = texto_rect.inflate(padding_menu_x * 2, ALTURA_BARRA_HERRAMIENTAS // 3); clickable_rect.centery = rect_barra_herramientas.centery 
        rects_opciones_menu_barra.append(clickable_rect); screen.blit(texto_surf, texto_rect)
        current_x_menu_draw += texto_rect.width + espacio_entre_menus + padding_menu_x 

    pygame.draw.circle(screen, BLANCO, (centro_x_circulo1, centro_y_circulos), radio_circulo_img, 2)
    pygame.draw.circle(screen, BLANCO, (centro_x_circulo2, centro_y_circulos), radio_circulo_img, 2)
    if pitch_image_base_grande: 
        try:
            valor_pitch_float = float(att_pitch_str); angulo_rotacion_pygame = -valor_pitch_float 
            imagen_pitch_rotada_grande = pygame.transform.rotate(pitch_image_base_grande, angulo_rotacion_pygame)
            diametro_claraboya = 2 * radio_circulo_img
            claraboya_surface = pygame.Surface((diametro_claraboya, diametro_claraboya), pygame.SRCALPHA); claraboya_surface.fill((0,0,0,0)) 
            offset_x = (diametro_claraboya - imagen_pitch_rotada_grande.get_width()) // 2
            offset_y = (diametro_claraboya - imagen_pitch_rotada_grande.get_height()) // 2
            claraboya_surface.blit(imagen_pitch_rotada_grande, (offset_x, offset_y))
            mask = pygame.Surface((diametro_claraboya, diametro_claraboya), pygame.SRCALPHA); mask.fill((0,0,0,0))
            pygame.draw.circle(mask, (255, 255, 255, 255), (radio_circulo_img, radio_circulo_img), radio_circulo_img)
            claraboya_surface.blit(mask, (0,0), special_flags=pygame.BLEND_RGBA_MULT)
            rect_claraboya_final = claraboya_surface.get_rect(center=(centro_x_circulo1, centro_y_circulos))
            screen.blit(claraboya_surface, rect_claraboya_final)
        except ValueError: pass 
    pygame.draw.circle(screen, BLANCO, (centro_x_circulo1, centro_y_circulos), radio_circulo_img, 2)
    for key, (angle_deg, etiqueta_str) in ANGULOS_MARCAS_ETIQUETAS_DEF.items(): 
        angle_rad = math.radians(angle_deg)
        x_inicio_marca = centro_x_circulo1 + RADIO_INICIO_MARCAS * math.cos(angle_rad); y_inicio_marca = centro_y_circulos + RADIO_INICIO_MARCAS * math.sin(angle_rad) 
        x_fin_marca = centro_x_circulo1 + RADIO_FIN_MARCAS * math.cos(angle_rad); y_fin_marca = centro_y_circulos + RADIO_FIN_MARCAS * math.sin(angle_rad)
        pygame.draw.line(screen, COLOR_MARCA_GRADO, (x_inicio_marca, y_inicio_marca), (x_fin_marca, y_fin_marca), GROSOR_MARCA_GRADO)
        etiqueta_surf = font.render(etiqueta_str, True, COLOR_ETIQUETA_GRADO) 
        x_texto_etiqueta = centro_x_circulo1 + RADIO_POSICION_TEXTO_ETIQUETA * math.cos(angle_rad); y_texto_etiqueta = centro_y_circulos + RADIO_POSICION_TEXTO_ETIQUETA * math.sin(angle_rad)
        etiqueta_rect = etiqueta_surf.get_rect(center=(int(x_texto_etiqueta), int(y_texto_etiqueta))); screen.blit(etiqueta_surf, etiqueta_rect)
    if att_pitch_str != "N/A":
        try:
            valor_pitch_float = float(att_pitch_str)
            pitch_valor_surf = font_circulos_textos.render(f"{valor_pitch_float:+.1f}°", True, BLANCO) 
            y_pos_texto_pitch = centro_y_circulos + radio_circulo_img * 0.0282
            pitch_valor_rect = pitch_valor_surf.get_rect(center=(centro_x_circulo1, y_pos_texto_pitch)); screen.blit(pitch_valor_surf, pitch_valor_rect)
            pos_flecha_pitch_x = pitch_valor_rect.left - OFFSET_FLECHA_TEXTO - (LONGITUD_FLECHA_DIR // 2); pos_flecha_pitch_y_centro = pitch_valor_rect.centery
            if valor_pitch_float > 0.1: 
                pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), 2)
                pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x - ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), 2)
                pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x + ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), 2)
            elif valor_pitch_float < -0.1: 
                pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), 2)
                pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x - ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), 2)
                pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x + ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), 2)
        except ValueError: pass 
    if roll_image_base_grande: 
        try:
            valor_roll_float = float(att_roll_str); angulo_rotacion_pygame_roll = -valor_roll_float 
            imagen_roll_rotada_grande = pygame.transform.rotate(roll_image_base_grande, angulo_rotacion_pygame_roll)
            diametro_claraboya_roll = 2 * radio_circulo_img 
            claraboya_surface_roll = pygame.Surface((diametro_claraboya_roll, diametro_claraboya_roll), pygame.SRCALPHA); claraboya_surface_roll.fill((0,0,0,0)) 
            offset_x_roll = (diametro_claraboya_roll - imagen_roll_rotada_grande.get_width()) // 2
            offset_y_roll = (diametro_claraboya_roll - imagen_roll_rotada_grande.get_height()) // 2
            claraboya_surface_roll.blit(imagen_roll_rotada_grande, (offset_x_roll, offset_y_roll))
            mask_roll = pygame.Surface((diametro_claraboya_roll, diametro_claraboya_roll), pygame.SRCALPHA); mask_roll.fill((0,0,0,0))
            pygame.draw.circle(mask_roll, (255, 255, 255, 255), (radio_circulo_img, radio_circulo_img), radio_circulo_img)
            claraboya_surface_roll.blit(mask_roll, (0,0), special_flags=pygame.BLEND_RGBA_MULT)
            rect_claraboya_final_roll = claraboya_surface_roll.get_rect(center=(centro_x_circulo2, centro_y_circulos))
            screen.blit(claraboya_surface_roll, rect_claraboya_final_roll)
        except ValueError: pass 
    pygame.draw.circle(screen, BLANCO, (centro_x_circulo2, centro_y_circulos), radio_circulo_img, 2)
    for key, (angle_deg, etiqueta_str) in ANGULOS_MARCAS_ETIQUETAS_DEF.items(): 
        angle_rad = math.radians(angle_deg)
        x_inicio_marca_roll = centro_x_circulo2 + RADIO_INICIO_MARCAS * math.cos(angle_rad); y_inicio_marca_roll = centro_y_circulos + RADIO_INICIO_MARCAS * math.sin(angle_rad) 
        x_fin_marca_roll = centro_x_circulo2 + RADIO_FIN_MARCAS * math.cos(angle_rad); y_fin_marca_roll = centro_y_circulos + RADIO_FIN_MARCAS * math.sin(angle_rad)
        pygame.draw.line(screen, COLOR_MARCA_GRADO, (x_inicio_marca_roll, y_inicio_marca_roll), (x_fin_marca_roll, y_fin_marca_roll), GROSOR_MARCA_GRADO)
        etiqueta_surf_roll = font.render(etiqueta_str, True, COLOR_ETIQUETA_GRADO) 
        x_texto_etiqueta_roll = centro_x_circulo2 + RADIO_POSICION_TEXTO_ETIQUETA * math.cos(angle_rad); y_texto_etiqueta_roll = centro_y_circulos + RADIO_POSICION_TEXTO_ETIQUETA * math.sin(angle_rad)
        etiqueta_rect_roll = etiqueta_surf_roll.get_rect(center=(int(x_texto_etiqueta_roll), int(y_texto_etiqueta_roll))); screen.blit(etiqueta_surf_roll, etiqueta_rect_roll)
    if att_roll_str != "N/A":
        try:
            valor_roll_float = float(att_roll_str)
            roll_valor_surf = font_circulos_textos.render(f"{valor_roll_float:+.1f}°", True, BLANCO) 
            y_pos_texto_roll = centro_y_circulos + radio_circulo_img * 0.0282
            roll_valor_rect = roll_valor_surf.get_rect(center=(centro_x_circulo2, y_pos_texto_roll)); screen.blit(roll_valor_surf, roll_valor_rect)
            letra_roll_str = ""
            if valor_roll_float > 0.1: letra_roll_str = "S"
            elif valor_roll_float < -0.1: letra_roll_str = "P"
            if letra_roll_str:
                letra_roll_surf = font_circulos_textos.render(letra_roll_str, True, COLOR_LETRA_ROLL) 
                letra_roll_rect = letra_roll_surf.get_rect(midtop=(roll_valor_rect.centerx, roll_valor_rect.bottom + OFFSET_LETRA_ROLL_Y)); screen.blit(letra_roll_surf, letra_roll_rect)
            pos_flecha_roll_y_centro = roll_valor_rect.centery
            if valor_roll_float > 0.1: 
                pos_flecha_roll_x = roll_valor_rect.right + OFFSET_FLECHA_TEXTO + (LONGITUD_FLECHA_DIR // 2)
                pygame.draw.line(screen, VERDE, (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                pygame.draw.line(screen, VERDE, (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro - ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                pygame.draw.line(screen, VERDE, (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro + ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
            elif valor_roll_float < -0.1: 
                pos_flecha_roll_x = roll_valor_rect.left - OFFSET_FLECHA_TEXTO - (LONGITUD_FLECHA_DIR // 2)
                pygame.draw.line(screen, ROJO, (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                pygame.draw.line(screen, ROJO, (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro - ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                pygame.draw.line(screen, ROJO, (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro + ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
        except ValueError: pass
    espacio_entre_cajas_vertical = 10; ancho_cajas_datos = 280; x_inicio_cajas_datos = area_izquierda_rect.right + 10 
    altura_caja_latlon = 120; y_caja_latlon = ALTURA_BARRA_HERRAMIENTAS + espacio_entre_cajas_vertical
    dim_caja_gll = [x_inicio_cajas_datos, y_caja_latlon, ancho_cajas_datos, altura_caja_latlon]
    altura_caja_rumbo_vel = 120; y_caja_rumbo_vel = y_caja_latlon + altura_caja_latlon + espacio_entre_cajas_vertical
    dim_caja_rumbo_vel = [x_inicio_cajas_datos, y_caja_rumbo_vel, ancho_cajas_datos, altura_caja_rumbo_vel]
    altura_caja_cabeceo = 120; y_caja_cabeceo = y_caja_rumbo_vel + altura_caja_rumbo_vel + espacio_entre_cajas_vertical
    dim_caja_att = [x_inicio_cajas_datos, y_caja_cabeceo, ancho_cajas_datos, altura_caja_cabeceo]
    pygame.draw.rect(screen, COLOR_CAJA_DATOS_FONDO, dim_caja_gll); pygame.draw.rect(screen, COLOR_CAJA_DATOS_BORDE, dim_caja_gll, 1) 
    pygame.draw.rect(screen, COLOR_CAJA_DATOS_FONDO, dim_caja_rumbo_vel); pygame.draw.rect(screen, COLOR_CAJA_DATOS_BORDE, dim_caja_rumbo_vel, 1)
    pygame.draw.rect(screen, COLOR_CAJA_DATOS_FONDO, dim_caja_att); pygame.draw.rect(screen, COLOR_CAJA_DATOS_BORDE, dim_caja_att, 1)
    text_surface_titulo_latlon = font.render(texto_latitud_lon_titulo, True, COLOR_CAJA_DATOS_TEXTO) 
    text_rect_titulo_latlon = text_surface_titulo_latlon.get_rect(centerx = dim_caja_gll[0] + dim_caja_gll[2] // 2, top = dim_caja_gll[1] + 5 )
    screen.blit(text_surface_titulo_latlon, text_rect_titulo_latlon)
    text_surface_lat_data = font_datos_grandes.render(latitude_str, True, COLOR_CAJA_DATOS_TEXTO)
    text_rect_lat_data = text_surface_lat_data.get_rect(centerx = dim_caja_gll[0] + dim_caja_gll[2] // 2, top = text_rect_titulo_latlon.bottom + 2)
    screen.blit(text_surface_lat_data, text_rect_lat_data)
    text_surface_lon_data = font_datos_grandes.render(longitude_str, True, COLOR_CAJA_DATOS_TEXTO)
    text_rect_lon_data = text_surface_lon_data.get_rect(centerx = dim_caja_gll[0] + dim_caja_gll[2] // 2, top = text_rect_lat_data.bottom + 2)
    screen.blit(text_surface_lon_data, text_rect_lon_data)
    padding_horizontal_caja = 15; y_pos_rumbo_vel = dim_caja_rumbo_vel[1] + 10 
    rumbo_etiqueta_surf = font.render("RUMBO          :", True, COLOR_CAJA_DATOS_TEXTO)
    rumbo_etiqueta_rect = rumbo_etiqueta_surf.get_rect(left=dim_caja_rumbo_vel[0] + padding_horizontal_caja, top=y_pos_rumbo_vel)
    rumbo_valor_surf = font_datos_grandes.render(heading_str, True, COLOR_CAJA_DATOS_TEXTO)
    rumbo_valor_rect = rumbo_valor_surf.get_rect(left=rumbo_etiqueta_rect.right + 5, centery=rumbo_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2 ) 
    screen.blit(rumbo_etiqueta_surf, rumbo_etiqueta_rect); screen.blit(rumbo_valor_surf, rumbo_valor_rect)
    y_pos_velocidad = rumbo_etiqueta_rect.top + font_datos_grandes.get_linesize() + 5 
    vel_etiqueta_surf = font.render("VELOCIDAD :", True, COLOR_CAJA_DATOS_TEXTO)
    vel_etiqueta_rect = vel_etiqueta_surf.get_rect(left=dim_caja_rumbo_vel[0] + padding_horizontal_caja, top=y_pos_velocidad)
    vel_valor_surf = font_datos_grandes.render(speed_str, True, COLOR_CAJA_DATOS_TEXTO)
    vel_valor_rect = vel_valor_surf.get_rect(left=vel_etiqueta_rect.right + 5, centery=vel_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2)
    screen.blit(vel_etiqueta_surf, vel_etiqueta_rect); screen.blit(vel_valor_surf, vel_valor_rect)
    text_surface_titulo_cabeceo = font.render(texto_actitud_titulo, True, COLOR_CAJA_DATOS_TEXTO) 
    text_rect_titulo_cabeceo = text_surface_titulo_cabeceo.get_rect(centerx = dim_caja_att[0] + dim_caja_att[2] // 2, top = dim_caja_att[1] + 10)
    screen.blit(text_surface_titulo_cabeceo, text_rect_titulo_cabeceo)
    current_y_att = text_rect_titulo_cabeceo.bottom + 10; pitch_etiqueta_str = "PITCH :"; pitch_valor_str = "N/A"
    if att_pitch_str != "N/A":
        try: pitch_valor_str = f"{float(att_pitch_str):+.0f}°"
        except ValueError: pass 
    pitch_etiqueta_surf = font.render(pitch_etiqueta_str, True, COLOR_CAJA_DATOS_TEXTO)
    pitch_etiqueta_rect = pitch_etiqueta_surf.get_rect(left=dim_caja_att[0] + padding_horizontal_caja, top=current_y_att)
    pitch_valor_surf = font_datos_grandes.render(pitch_valor_str, True, COLOR_CAJA_DATOS_TEXTO)
    pitch_valor_rect = pitch_valor_surf.get_rect(left=pitch_etiqueta_rect.right + 5, centery=pitch_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2)
    screen.blit(pitch_etiqueta_surf, pitch_etiqueta_rect); screen.blit(pitch_valor_surf, pitch_valor_rect)
    current_y_att += font_datos_grandes.get_linesize() + 5; roll_etiqueta_str = "ROLL  : "; roll_valor_display_str = "N/A"; roll_direccion_str = ""     
    if att_roll_str != "N/A":
        try:
            roll_val = float(att_roll_str); roll_valor_display_str = f"{roll_val:+.0f}°" 
            if roll_val > 0.1: roll_direccion_str = "ESTRIBOR"
            elif roll_val < -0.1: roll_direccion_str = "BABOR"
        except ValueError: pass 
    roll_etiqueta_surf = font.render(roll_etiqueta_str, True, COLOR_CAJA_DATOS_TEXTO)
    roll_etiqueta_rect = roll_etiqueta_surf.get_rect(left=dim_caja_att[0] + padding_horizontal_caja, top=current_y_att)
    roll_valor_surf = font_datos_grandes.render(roll_valor_display_str, True, COLOR_CAJA_DATOS_TEXTO)
    roll_valor_rect = roll_valor_surf.get_rect(left=roll_etiqueta_rect.right + 5, centery=roll_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2)
    screen.blit(roll_etiqueta_surf, roll_etiqueta_rect); screen.blit(roll_valor_surf, roll_valor_rect) 
    if roll_direccion_str: 
        roll_direccion_surf = font.render(roll_direccion_str, True, COLOR_CAJA_DATOS_TEXTO)
        roll_direccion_rect = roll_direccion_surf.get_rect(left=roll_valor_rect.right + 5, centery=roll_etiqueta_rect.centery) 
        screen.blit(roll_direccion_surf, roll_direccion_rect)
    if serial_port_available and ser and ser.is_open:
        ahora = pygame.time.get_ticks()
        if ahora - ultima_vez_datos_recibidos > UMBRAL_SIN_DATOS_MS:
            mensaje_no_datos = "NO HAY DATOS NMEA"
            texto_no_datos_surf = font.render(mensaje_no_datos, True, ROJO)
            rect_texto_no_datos = texto_no_datos_surf.get_rect(center=area_izquierda_rect.center)
            screen.blit(texto_no_datos_surf, rect_texto_no_datos)
    elif not serial_port_available: 
        ahora = pygame.time.get_ticks()
        mensaje_desconexion = "Puerto NMEA desconectado."
        texto_desconexion_surf = font.render(mensaje_desconexion, True, ROJO)
        rect_texto_desconexion = texto_desconexion_surf.get_rect(center=area_izquierda_rect.center)
        screen.blit(texto_desconexion_surf, rect_texto_desconexion)

    if mostrar_ventana_config_serial:
        pygame.draw.rect(screen, COLOR_VENTANA_FONDO, rect_ventana_config)
        pygame.draw.line(screen, COLOR_BORDE_VENTANA_CLARO, rect_ventana_config.topleft, rect_ventana_config.topright, 2) 
        pygame.draw.line(screen, COLOR_BORDE_VENTANA_CLARO, rect_ventana_config.topleft, rect_ventana_config.bottomleft, 2) 
        pygame.draw.line(screen, COLOR_BORDE_VENTANA_OSCURO, rect_ventana_config.bottomleft, rect_ventana_config.bottomright, 2) 
        pygame.draw.line(screen, COLOR_BORDE_VENTANA_OSCURO, rect_ventana_config.topright, rect_ventana_config.bottomright, 2) 
        titulo_surf = font.render("Selecionar", True, COLOR_TEXTO_NORMAL)
        screen.blit(titulo_surf, (rect_ventana_config.centerx - titulo_surf.get_width() // 2, rect_ventana_config.top + 15))
        pygame.draw.rect(screen, COLOR_BOTON_FONDO_3D, rect_boton_cerrar_config) 
        pygame.draw.line(screen, COLOR_BOTON_BORDE_CLARO_3D, rect_boton_cerrar_config.topleft, rect_boton_cerrar_config.topright, 1)
        pygame.draw.line(screen, COLOR_BOTON_BORDE_CLARO_3D, rect_boton_cerrar_config.topleft, pygame.math.Vector2(rect_boton_cerrar_config.left, rect_boton_cerrar_config.bottom -1), 1)
        pygame.draw.line(screen, COLOR_BOTON_BORDE_OSCURO_3D, pygame.math.Vector2(rect_boton_cerrar_config.left, rect_boton_cerrar_config.bottom -1), rect_boton_cerrar_config.bottomright, 1)
        pygame.draw.line(screen, COLOR_BOTON_BORDE_OSCURO_3D, pygame.math.Vector2(rect_boton_cerrar_config.right -1, rect_boton_cerrar_config.top), rect_boton_cerrar_config.bottomright, 1)
        cerrar_text = font.render("X", True, COLOR_TEXTO_NORMAL)
        screen.blit(cerrar_text, cerrar_text.get_rect(center=rect_boton_cerrar_config.center))
        
        # Dibujado de elementos estáticos de la ventana de config puerto
        label_puerto_surf = font.render("Puerto:", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_puerto_surf, (rect_ventana_config.left + padding_interno_config, rect_input_puerto_config.centery - label_puerto_surf.get_height()//2))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO, rect_input_puerto_config, 0) 
        pygame.draw.line(screen, COLOR_INPUT_BORDE_OSCURO_3D, rect_input_puerto_config.topleft, rect_input_puerto_config.topright, 1)
        pygame.draw.line(screen, COLOR_INPUT_BORDE_OSCURO_3D, rect_input_puerto_config.topleft, pygame.math.Vector2(rect_input_puerto_config.left, rect_input_puerto_config.bottom -1), 1)
        pygame.draw.line(screen, COLOR_INPUT_BORDE_CLARO_3D, pygame.math.Vector2(rect_input_puerto_config.left, rect_input_puerto_config.bottom -1), rect_input_puerto_config.bottomright, 1)
        pygame.draw.line(screen, COLOR_INPUT_BORDE_CLARO_3D, pygame.math.Vector2(rect_input_puerto_config.right -1, rect_input_puerto_config.top), rect_input_puerto_config.bottomright, 1)
        input_puerto_surf = font.render(input_puerto_str, True, COLOR_TEXTO_NORMAL)
        screen.blit(input_puerto_surf, (rect_input_puerto_config.left + 5, rect_input_puerto_config.centery - input_puerto_surf.get_height() // 2))
        pygame.draw.polygon(screen, COLOR_TEXTO_NORMAL, [(rect_input_puerto_config.right - 15, rect_input_puerto_config.centery - 3),(rect_input_puerto_config.right - 5, rect_input_puerto_config.centery - 3),(rect_input_puerto_config.right - 10, rect_input_puerto_config.centery + 3)])

        label_baudios_surf = font.render("Baudios:", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_baudios_surf, (rect_ventana_config.left + padding_interno_config, rect_input_baudios_display_config.centery - label_baudios_surf.get_height()//2))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO, rect_input_baudios_display_config, 0) 
        pygame.draw.line(screen, COLOR_INPUT_BORDE_OSCURO_3D, rect_input_baudios_display_config.topleft, rect_input_baudios_display_config.topright, 1)
        pygame.draw.line(screen, COLOR_INPUT_BORDE_OSCURO_3D, rect_input_baudios_display_config.topleft, pygame.math.Vector2(rect_input_baudios_display_config.left, rect_input_baudios_display_config.bottom -1), 1)
        pygame.draw.line(screen, COLOR_INPUT_BORDE_CLARO_3D, pygame.math.Vector2(rect_input_baudios_display_config.left, rect_input_baudios_display_config.bottom -1), rect_input_baudios_display_config.bottomright, 1)
        pygame.draw.line(screen, COLOR_INPUT_BORDE_CLARO_3D, pygame.math.Vector2(rect_input_baudios_display_config.right -1, rect_input_baudios_display_config.top), rect_input_baudios_display_config.bottomright, 1)
        baudios_surf = font.render(str(lista_baudios_seleccionables[input_baudios_idx]), True, COLOR_TEXTO_NORMAL)
        screen.blit(baudios_surf, baudios_surf.get_rect(center=rect_input_baudios_display_config.center))
        pygame.draw.polygon(screen, COLOR_TEXTO_NORMAL, [(rect_input_baudios_display_config.right - 15, rect_input_baudios_display_config.centery - 3),(rect_input_baudios_display_config.right - 5, rect_input_baudios_display_config.centery - 3),(rect_input_baudios_display_config.right - 10, rect_input_baudios_display_config.centery + 3)])
        
        pygame.draw.rect(screen, COLOR_BOTON_FONDO_3D, rect_boton_guardar_config) 
        pygame.draw.line(screen, COLOR_BOTON_BORDE_CLARO_3D, rect_boton_guardar_config.topleft, rect_boton_guardar_config.topright, 1)
        pygame.draw.line(screen, COLOR_BOTON_BORDE_CLARO_3D, rect_boton_guardar_config.topleft, pygame.math.Vector2(rect_boton_guardar_config.left, rect_boton_guardar_config.bottom -1), 1)
        pygame.draw.line(screen, COLOR_BOTON_BORDE_OSCURO_3D, pygame.math.Vector2(rect_boton_guardar_config.left, rect_boton_guardar_config.bottom -1), rect_boton_guardar_config.bottomright, 1)
        pygame.draw.line(screen, COLOR_BOTON_BORDE_OSCURO_3D, pygame.math.Vector2(rect_boton_guardar_config.right -1, rect_boton_guardar_config.top), rect_boton_guardar_config.bottomright, 1)
        guardar_surf = font.render("Guardar y Aplicar", True, COLOR_TEXTO_NORMAL)
        screen.blit(guardar_surf, guardar_surf.get_rect(center=rect_boton_guardar_config.center))

        # Dibujar DESPLEGABLES al final para que aparezcan encima
        if puerto_dropdown_activo:
            lista_rects_items_puerto.clear()
            item_height = input_puerto_surf.get_height() + 4 
            dropdown_height = min(item_height * len(lista_puertos_detectados), ventana_config_height - (rect_input_puerto_config.bottom - ventana_config_y) - 10 - (rect_input_baudios_display_config.height + 15 + 50) - (rect_boton_guardar_config.height + 20)) 
            rect_lista_puertos_desplegable = pygame.Rect(rect_input_puerto_config.left, rect_input_puerto_config.bottom, rect_input_puerto_config.width, dropdown_height)
            pygame.draw.rect(screen, COLOR_DROPDOWN_FONDO, rect_lista_puertos_desplegable); pygame.draw.rect(screen, COLOR_DROPDOWN_BORDE, rect_lista_puertos_desplegable, 1) 
            for i, port_name in enumerate(lista_puertos_detectados):
                item_rect = pygame.Rect(rect_lista_puertos_desplegable.left, rect_lista_puertos_desplegable.top + i * item_height, rect_lista_puertos_desplegable.width, item_height)
                if item_rect.bottom > rect_lista_puertos_desplegable.bottom: break
                lista_rects_items_puerto.append(item_rect)
                item_surf = font.render(port_name, True, COLOR_TEXTO_NORMAL)
                screen.blit(item_surf, (item_rect.left + 5, item_rect.centery - item_surf.get_height() // 2))
        
        elif baudios_dropdown_activo: 
            lista_rects_items_baudios.clear()
            item_height = baudios_surf.get_height() + 4 
            dropdown_height = min(item_height * len(lista_baudios_seleccionables), ventana_config_height - (rect_input_baudios_display_config.bottom - ventana_config_y) - 10 - (rect_boton_guardar_config.height + 20)) 
            rect_lista_baudios_desplegable = pygame.Rect(rect_input_baudios_display_config.left, rect_input_baudios_display_config.bottom, rect_input_baudios_display_config.width, dropdown_height)
            pygame.draw.rect(screen, COLOR_DROPDOWN_FONDO, rect_lista_baudios_desplegable); pygame.draw.rect(screen, COLOR_DROPDOWN_BORDE, rect_lista_baudios_desplegable, 1)
            for i, baud_rate in enumerate(lista_baudios_seleccionables):
                item_rect = pygame.Rect(rect_lista_baudios_desplegable.left, rect_lista_baudios_desplegable.top + i * item_height, rect_lista_baudios_desplegable.width, item_height)
                if item_rect.bottom > rect_lista_baudios_desplegable.bottom: break
                lista_rects_items_baudios.append(item_rect)
                item_surf = font.render(str(baud_rate), True, COLOR_TEXTO_NORMAL)
                screen.blit(item_surf, (item_rect.left + 5, item_rect.centery - item_surf.get_height() // 2))

    elif mostrar_ventana_alarma:
        pygame.draw.rect(screen, (240,240,240), rect_ventana_alarma) 
        pygame.draw.rect(screen, COLOR_BORDE_VENTANA, rect_ventana_alarma, 2)
        titulo_alarma_surf = font.render("Configuración de Alarmas", True, COLOR_TEXTO_NORMAL)
        screen.blit(titulo_alarma_surf, (rect_ventana_alarma.centerx - titulo_alarma_surf.get_width() // 2, rect_ventana_alarma.top + 15))
        y_start_inputs = rect_ventana_alarma.top + 70 
        input_height = 30; label_width_alarma = 150; input_width_alarma = 80; padding_y_alarma = 25
        label_x_alarma = rect_ventana_alarma.left + 20
        input_x_alarma = label_x_alarma + label_width_alarma + 10

        rect_label_pitch_alarma = pygame.Rect(label_x_alarma, y_start_inputs, label_width_alarma, input_height)
        rect_input_pitch_alarma = pygame.Rect(input_x_alarma, y_start_inputs, input_width_alarma, input_height)
        label_pitch_surf = font.render("Pitch (5 a 30):", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_pitch_surf, label_pitch_surf.get_rect(centery=rect_label_pitch_alarma.centery, left=rect_label_pitch_alarma.left))
        color_fondo_input_pitch = pygame.Color('lightskyblue1') if input_alarma_activo == "pitch" else COLOR_INPUT_FONDO
        pygame.draw.rect(screen, color_fondo_input_pitch, rect_input_pitch_alarma)
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_pitch_alarma, 1)
        input_pitch_surf = font.render(valores_ui_input_alarma["pitch"], True, COLOR_TEXTO_NORMAL)
        screen.blit(input_pitch_surf, (rect_input_pitch_alarma.left + 5, rect_input_pitch_alarma.centery - input_pitch_surf.get_height() // 2))

        y_current_alarma = y_start_inputs + input_height + padding_y_alarma
        rect_label_roll_alarma = pygame.Rect(label_x_alarma, y_current_alarma, label_width_alarma, input_height)
        rect_input_roll_alarma = pygame.Rect(input_x_alarma, y_current_alarma, input_width_alarma, input_height)
        label_roll_surf = font.render("Roll (5 a 30):", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_roll_surf, label_roll_surf.get_rect(centery=rect_label_roll_alarma.centery, left=rect_label_roll_alarma.left))
        color_fondo_input_roll = pygame.Color('lightskyblue1') if input_alarma_activo == "roll" else COLOR_INPUT_FONDO
        pygame.draw.rect(screen, color_fondo_input_roll, rect_input_roll_alarma)
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_roll_alarma, 1)
        input_roll_surf = font.render(valores_ui_input_alarma["roll"], True, COLOR_TEXTO_NORMAL)
        screen.blit(input_roll_surf, (rect_input_roll_alarma.left + 5, rect_input_roll_alarma.centery - input_roll_surf.get_height() // 2))

        button_width_alarma = 120; button_height_alarma = 40
        y_botones_alarma = rect_ventana_alarma.bottom - button_height_alarma - 20 
        rect_boton_guardar_alarma = pygame.Rect(rect_ventana_alarma.centerx - button_width_alarma - 10, y_botones_alarma, button_width_alarma, button_height_alarma)
        rect_boton_salir_alarma = pygame.Rect(rect_ventana_alarma.centerx + 10, y_botones_alarma, button_width_alarma, button_height_alarma)
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_guardar_alarma); pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_guardar_alarma, 1) 
        guardar_alarma_surf = font.render("Guardar", True, COLOR_TEXTO_NORMAL)
        screen.blit(guardar_alarma_surf, guardar_alarma_surf.get_rect(center=rect_boton_guardar_alarma.center))
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_salir_alarma); pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_salir_alarma, 1) 
        salir_alarma_surf = font.render("Salir", True, COLOR_TEXTO_NORMAL)
        screen.blit(salir_alarma_surf, salir_alarma_surf.get_rect(center=rect_boton_salir_alarma.center))

    elif mostrar_ventana_acerca_de:
        rect_ventana_acerca_de = pygame.Rect(250, 150, 400, 250) 
        pygame.draw.rect(screen, (240, 240, 240), rect_ventana_acerca_de) 
        pygame.draw.rect(screen, COLOR_BORDE_VENTANA, rect_ventana_acerca_de, 2)
        titulo_acerca_surf = font.render("Acerca de Lalito", True, COLOR_TEXTO_NORMAL)
        screen.blit(titulo_acerca_surf, (rect_ventana_acerca_de.centerx - titulo_acerca_surf.get_width() // 2, rect_ventana_acerca_de.top + 15))
        texto_info = ["Programa visor de Datos NMEA", "Versión: 1.0", "Realizado por: Hdelacruz", "Email: hugo_delacruz@hotmail.com","                                        2025"]
        y_offset_info = rect_ventana_acerca_de.top + 60
        for linea in texto_info:
            info_surf = font.render(linea, True, COLOR_TEXTO_NORMAL)
            screen.blit(info_surf, (rect_ventana_acerca_de.left + 20, y_offset_info))
            y_offset_info += info_surf.get_height() + 10 
        rect_boton_cerrar_acerca_de = pygame.Rect(rect_ventana_acerca_de.centerx - 50, rect_ventana_acerca_de.bottom - 50, 100, 30)
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_cerrar_acerca_de); pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_cerrar_acerca_de, 1) 
        cerrar_acerca_surf = font.render("Cerrar", True, COLOR_TEXTO_NORMAL)
        screen.blit(cerrar_acerca_surf, cerrar_acerca_surf.get_rect(center=rect_boton_cerrar_acerca_de.center))
        
    pygame.display.flip()
    reloj.tick(60)

if serial_port_available and ser is not None: 
    ser.close() 
pygame.quit()



