# immportamos las bibliotecas pygame y math
import pygame
import math
import os # Importar el módulo os
import serial # Importación corregida
import json # Para configuración persistente
from serial.tools.list_ports import comports # Para detectar puertos
from pygame.locals import * # Asegurar que locals esté después de pygame

# Importaciones adicionales para logging y Thingspeak
import requests
import csv
from datetime import datetime
import time # time ya estaba importado indirectamente, pero mejor explicitarlo si se usa time.time()

# Definimos algunos colores base primero
NEGRO = (0, 0, 0) 
BLANCO = (255, 255, 255) 
VERDE = (0, 255, 0) 
ROJO = (255, 0, 0) 
AZUL = (0, 0, 255)

# Constantes globales tempranas
ALTURA_BARRA_HERRAMIENTAS = 30
PI = 3.141592653

# --- CONFIGURACIÓN PARA LOGGING Y THINGSPEAK ---
API_KEY_THINGSPEAK = "5TRR6EXF6N5CZF54"  # Clave de escritura para ThingSpeak
THINGSPEAK_URL = "https://api.thingspeak.com/update"
CSV_FILENAME = "nmea_log.csv"
INTERVALO_ENVIO_DATOS_S = 15 # Intervalo para guardar en CSV y enviar a ThingSpeak (en segundos)
INTERVALO_REPETICION_ALARMA_ROLL_S = 10 # Intervalo para repetir el sonido de alarma de ROLL si la condición persiste
INTERVALO_REPETICION_ALARMA_PITCH_S = 5   # Intervalo para repetir el sonido de alarma de PITCH si la condición persiste

# Nombre del archivo de configuración para puerto serial (existente)
ARCHIVO_CONFIG_SERIAL = "config_serial.json"

# Variables para la configuración de alarmas (definidas globalmente ANTES de su uso)
ARCHIVO_CONFIG_ALARMA = "config_alarma.json"
valores_alarma = {
    "max_pitch_pos": "15", 
    "min_pitch_neg": "-15",
    "max_roll_pos": "15",
    "min_roll_neg": "-15"
}

lista_puertos_detectados = [] # Para almacenar los puertos detectados

# Variables para reconexión automática
ultimo_intento_reconeccion_tiempo = 0
INTERVALO_RECONECCION_MS = 5000 # 5 segundos

# Variables para el mensaje "NO HAY DATOS"
ultima_vez_datos_recibidos = 0 # Se inicializará correctamente después de pygame.init()
UMBRAL_SIN_DATOS_MS = 3000 # 3 segundos

# Variables globales para datos NMEA destinados a ThingSpeak/CSV
ts_pitch_float = 0.0
ts_roll_float = 0.0
ts_lat_decimal = 0.0
ts_lon_decimal = 0.0
ts_speed_float = 0.0
ts_heading_float = 0.0
ts_timestamp_str = "N/A" # Formato: "YYYY-MM-DD HH:MM:SS"

# Variable para temporizador de envío de datos (se inicializará con time.time() más adelante)
ultima_vez_envio_datos = 0 

# Variables de estado para alarmas de Roll
alarma_roll_babor_activa = False  # True si la condición de alarma de babor está presente
alarma_roll_estribor_activa = False # True si la condición de alarma de estribor está presente
ultima_reproduccion_alarma_babor_tiempo = 0.0 # time.time() de la última reproducción
ultima_reproduccion_alarma_estribor_tiempo = 0.0 # time.time() de la última reproducción

# Variables de estado para alarmas de Pitch
alarma_pitch_sentado_activa = False # True si la condición de Pitch positivo excesivo está presente
alarma_pitch_encabuzado_activa = False # True si la condición de Pitch negativo excesivo está presente
ultima_reproduccion_alarma_sentado_tiempo = 0.0
ultima_reproduccion_alarma_encabuzado_tiempo = 0.0

# Variables para el gestor de sonido de alarma alternado
sonido_alarma_actualmente_reproduciendo = None # Objeto Sound que está sonando, o None
tiempo_ultimo_sonido_iniciado = 0.0       # time.time() de cuándo comenzó el sonido actual
INDICE_PROXIMA_ALARMA_A_SONAR = 0         # Para ciclar entre alarmas activas que están listas
PAUSA_ENTRE_SONIDOS_ALTERNADOS_S = 1.0    # Pausa después de que un sonido termina antes de alternar

# Funciones para cargar y guardar configuración serial
def cargar_configuracion_serial():
    try:
        with open(ARCHIVO_CONFIG_SERIAL, 'r') as f:
            config = json.load(f)
            return config.get('puerto', 'COM9'), int(config.get('baudios', 9600))
    except (FileNotFoundError, json.JSONDecodeError, ValueError):
        return 'COM9', 9600 # Valores por defecto

def guardar_configuracion_serial(puerto, baudios):
    config = {'puerto': puerto, 'baudios': int(baudios)}
    try:
        with open(ARCHIVO_CONFIG_SERIAL, 'w') as f:
            json.dump(config, f, indent=4)
        print(f"Configuración guardada: Puerto={puerto}, Baudios={baudios}")
    except IOError:
        print(f"Error al guardar la configuración en {ARCHIVO_CONFIG_SERIAL}")

# Funciones para cargar y guardar configuración de alarma
def cargar_configuracion_alarma():
    global valores_alarma
    try:
        with open(ARCHIVO_CONFIG_ALARMA, 'r') as f:
            config = json.load(f)
            valores_alarma["max_pitch_pos"] = str(config.get('max_pitch_pos', "15"))
            valores_alarma["min_pitch_neg"] = str(config.get('min_pitch_neg', "-15"))
            valores_alarma["max_roll_pos"] = str(config.get('max_roll_pos', "15"))
            valores_alarma["min_roll_neg"] = str(config.get('min_roll_neg', "-15"))
            print(f"Configuración de alarma cargada: {valores_alarma}")
    except (FileNotFoundError, json.JSONDecodeError, ValueError) as e:
        print(f"Error al cargar config de alarma o no existe, usando valores por defecto. Error: {e}")
        # Los valores por defecto ya están en valores_alarma

def guardar_configuracion_alarma():
    try:
        with open(ARCHIVO_CONFIG_ALARMA, 'w') as f:
            json.dump(valores_alarma, f, indent=4)
        print(f"Configuración de alarma guardada: {valores_alarma}")
    except IOError:
        print(f"Error al guardar la configuración de alarma en {ARCHIVO_CONFIG_ALARMA}")

def obtener_estado_alarma_actual():
    """Determina el string del estado de alarma actual basado en las variables globales."""
    mensajes_alarma = []
    if alarma_roll_babor_activa:
        mensajes_alarma.append("ROLL BABOR")
    elif alarma_roll_estribor_activa: 
        mensajes_alarma.append("ROLL ESTRIBOR")
    
    if alarma_pitch_sentado_activa:
        mensajes_alarma.append("PITCH SENTADO")
    elif alarma_pitch_encabuzado_activa: 
        mensajes_alarma.append("PITCH ENCABUZADO")

    if not mensajes_alarma:
        return "SIN ALARMA"
    else:
        # Unir todos los mensajes de alarma activos. Usar " Y " o ", "
        # Ejemplo: "ALARMA ROLL BABOR Y PITCH SENTADO"
        return "ALARMA " + " Y ".join(mensajes_alarma)

# Funciones para logging CSV y envío a ThingSpeak (adaptadas del script original)
def init_csv():
    try:
        with open(CSV_FILENAME, 'x', newline='') as f: # CSV_FILENAME es global
            writer = csv.writer(f)
            writer.writerow(["FechaHora", "Pitch", "Roll", "Latitud", "Longitud", "Velocidad", "Rumbo"])
    except FileExistsError:
        pass

def guardar_csv():
    with open(CSV_FILENAME, 'a', newline='') as f:
        writer = csv.writer(f)
        writer.writerow([ts_timestamp_str, ts_pitch_float, ts_roll_float, ts_lat_decimal, ts_lon_decimal, ts_speed_float, ts_heading_float])

def enviar_thingspeak():
    payload = {
        'api_key': API_KEY_THINGSPEAK,
        'field1': ts_pitch_float,
        'field2': ts_roll_float,
        'field3': ts_lat_decimal,
        'field4': ts_lon_decimal,
        'field5': ts_speed_float,
        'field6': ts_heading_float,
        'field7': ts_timestamp_str
        # Se añadirá field8 dinámicamente
    }

    # Determinar estado de alarma para field8 usando la función auxiliar
    estado_alarma_roll_str = obtener_estado_alarma_actual()
    
    payload['field8'] = estado_alarma_roll_str
    
    # print(f"Debug ThingSpeak Payload: {payload}") # Línea de depuración eliminada/comentada

    try:
        r = requests.get(THINGSPEAK_URL, params=payload) # THINGSPEAK_URL es global
        if r.status_code == 200:
            print(f"[OK] Datos enviados a ThingSpeak: {ts_timestamp_str}")
        else:
            print(f"[ERROR] Respuesta ThingSpeak: {r.status_code} - {r.text}")
    except Exception as e:
        print(f"[ERROR] Conexión ThingSpeak: {e}")

def convertir_coord(coord_str, direccion, is_longitude=False):
    """Convierte coordenadas NMEA (d)ddmm.mmmm a grados decimales."""
    try:
        idx_punto = coord_str.find('.')
        if idx_punto == -1 or not coord_str or not direccion : # Verificar que coord_str y direccion no sean vacíos
            return 0.0 

        min_start_index = idx_punto - 2
        if min_start_index < 0: 
            return 0.0

        grados_str = coord_str[:min_start_index]
        minutos_str = coord_str[min_start_index:] 
        
        if not grados_str: 
            return 0.0

        grados = int(grados_str)
        minutos = float(minutos_str)
        
        decimal = grados + minutos / 60.0
        if direccion in ['S', 'W']:
            decimal *= -1
        return round(decimal, 6)
    except Exception as e:
        return 0.0 


# Inicializamos el motor de juegos
pygame.init()
pygame.mixer.init() # Inicializar el módulo mixer para sonidos

# Cargar y escalar imagen de fondo
script_dir = os.path.dirname(os.path.abspath(__file__)) # script_dir ya está definido aquí para las imágenes

# Cargar sonidos de alarma
try:
    ruta_alarma_babor = os.path.join(script_dir, "ALARMA_BABOR.mp3")
    ruta_alarma_estribor = os.path.join(script_dir, "ALARMA_ESTRIBOR.mp3")
    sonido_alarma_babor = pygame.mixer.Sound(ruta_alarma_babor)
    sonido_alarma_estribor = pygame.mixer.Sound(ruta_alarma_estribor)
    print("Archivos de alarma Roll MP3 cargados correctamente.")
    # Cargar sonidos de alarma de Pitch
    ruta_alarma_sentado = os.path.join(script_dir, "alarma_sentado.mp3")
    ruta_alarma_encabuzado = os.path.join(script_dir, "alarma_encabuzado.mp3")
    sonido_alarma_sentado = pygame.mixer.Sound(ruta_alarma_sentado)
    sonido_alarma_encabuzado = pygame.mixer.Sound(ruta_alarma_encabuzado)
    print("Archivos de alarma Pitch MP3 cargados correctamente.")
except pygame.error as e:
    print(f"Error al cargar archivos de sonido MP3: {e}")
    print("Asegúrate de que los archivos de alarma (ALARMA_BABOR.mp3, ALARMA_ESTRIBOR.mp3, alarma_sentado.mp3, alarma_encabuzado.mp3) estén en el mismo directorio que el script.")
    print("La funcionalidad de alarma sonora para los sonidos faltantes estará desactivada.")
    # Inicializar todos a None si hay cualquier error para ser seguros, o manejar individualmente
    if 'sonido_alarma_babor' not in locals(): sonido_alarma_babor = None # Si falla antes de esta carga
    if 'sonido_alarma_estribor' not in locals(): sonido_alarma_estribor = None
    sonido_alarma_sentado = None
    sonido_alarma_encabuzado = None

ultima_vez_datos_recibidos = pygame.time.get_ticks() # Inicialización correcta

# Cargar configuración serial al inicio
puerto, baudios = cargar_configuracion_serial()
print(f"Configuración cargada: Puerto={puerto}, Baudios={baudios}")

# Cargar configuración de alarma al inicio
cargar_configuracion_alarma()

ser = None 
serial_port_available = True

# Variables para la ventana de configuración del puerto serie
mostrar_ventana_config_serial = False
mostrar_ventana_acerca_de = False 
mostrar_ventana_alarma = False

input_alarma_activo = None 
rect_ventana_alarma = pygame.Rect(250, 100, 400, 350) 
rect_input_max_pitch_pos = None
rect_input_min_pitch_neg = None
rect_input_max_roll_pos = None
rect_input_min_roll_neg = None
rect_boton_guardar_alarma = None
rect_boton_salir_alarma = None

input_puerto_str = str(puerto) 
lista_baudios_seleccionables = sorted([4800, 9600, 19200, 38400, 57600, 115200]) 
try:
    input_baudios_idx = lista_baudios_seleccionables.index(baudios)
except ValueError:
    input_baudios_idx = 0 

rect_ventana_config = pygame.Rect(450, 100, 400, 350) 

COLOR_VENTANA_FONDO = (240, 240, 240) 
COLOR_TEXTO_NORMAL = NEGRO
COLOR_BORDE_VENTANA = (170, 170, 170) 
COLOR_BARRA_HERRAMIENTAS_FONDO = (220, 220, 220) 
COLOR_BARRA_HERRAMIENTAS_BORDE = (180, 180, 180)
COLOR_ITEM_MENU_TEXTO = NEGRO
COLOR_BOTON_FONDO = (225, 225, 225) 
COLOR_BOTON_BORDE = (150, 150, 150) 
COLOR_INPUT_FONDO = BLANCO
COLOR_INPUT_BORDE = (120, 120, 120) 
COLOR_DROPDOWN_FONDO = (250, 250, 250) 
COLOR_DROPDOWN_BORDE = (100, 100, 100)
COLOR_SELECCION_DROPDOWN = (200, 220, 255) 

COLOR_CAJA_DATOS_FONDO = BLANCO 
COLOR_CAJA_DATOS_BORDE = (120, 120, 120) 
COLOR_CAJA_DATOS_TEXTO = NEGRO 

input_puerto_activo = False 
puerto_dropdown_activo = False 
baudios_dropdown_activo = False 

rect_input_puerto_config = pygame.Rect(rect_ventana_config.left + 120, rect_ventana_config.top + 55, rect_ventana_config.width - 160, 30) 
rect_lista_puertos_desplegable = None 
lista_rects_items_puerto = [] 

rect_input_baudios_display_config = pygame.Rect(rect_ventana_config.left + 120, rect_ventana_config.top + 105, rect_ventana_config.width - 160, 30)
rect_lista_baudios_desplegable = None
lista_rects_items_baudios = []

rect_boton_guardar_config = pygame.Rect(rect_ventana_config.centerx - 75, rect_ventana_config.bottom - 60, 150, 40)
rect_boton_cerrar_config = pygame.Rect(rect_ventana_config.right - 35, rect_ventana_config.top + 5, 30, 30) 


try: 
    ser = serial.Serial(puerto, baudios) 
    print(f"Puerto serial {puerto} abierto con {baudios} baudios.")
except serial.SerialException as e: 
    print(f"Error opening serial port {puerto} with {baudios} baud: {e}") 
    serial_port_available = False
except Exception as e: 
    print(f"An unexpected error occurred opening serial port: {e}")
    serial_port_available = False

# Initialize NMEA data variables for UI
latitude_str = "N/A" 
longitude_str = "N/A" 
speed_str = "N/A" 
heading_str = "N/A"
att_heading_str = "N/A"
att_pitch_str = "N/A"
att_roll_str = "N/A"

# --- NMEA Parsing Functions (Unificadas) ---
def parse_pfec_gpatt(sentence):
    global att_heading_str, att_pitch_str, att_roll_str, ultima_vez_datos_recibidos
    global ts_pitch_float, ts_roll_float
    try:
        parts = sentence.split(',')
        if len(parts) >= 5 and parts[1] == "GPatt":
            att_heading_str = parts[2] if parts[2] else "N/A"
            
            raw_pitch = parts[3]
            att_pitch_str = raw_pitch if raw_pitch else "N/A"
            try: ts_pitch_float = float(raw_pitch)
            except (ValueError, TypeError): ts_pitch_float = 0.0 

            raw_roll_part = parts[4].split('*')[0]
            att_roll_str = raw_roll_part if raw_roll_part else "N/A"
            try: ts_roll_float = float(raw_roll_part)
            except (ValueError, TypeError): ts_roll_float = 0.0
            
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except Exception as e:
        print(f"Error parsing PFEC,GPatt: {sentence} - {e}")

def _actualizar_coordenadas_ui_y_ts(lat_raw_val, lat_dir, lon_raw_val, lon_dir):
    global latitude_str, longitude_str, ts_lat_decimal, ts_lon_decimal
    
    latitude_str_temp, longitude_str_temp = "N/A", "N/A"
    ts_lat_decimal_temp, ts_lon_decimal_temp = 0.0, 0.0

    if lat_raw_val and lat_dir and len(lat_raw_val) >=2:
        lat_deg_ui = lat_raw_val[:2]
        lat_min_full_ui = lat_raw_val[2:]
        try: lat_min_formatted_ui = f"{float(lat_min_full_ui):.3f}"
        except ValueError: lat_min_formatted_ui = lat_min_full_ui 
        latitude_str_temp = f"{lat_deg_ui}° {lat_min_formatted_ui}' {lat_dir}"
        ts_lat_decimal_temp = convertir_coord(lat_raw_val, lat_dir, is_longitude=False)
    
    if lon_raw_val and lon_dir and len(lon_raw_val) >=3:
        lon_parts_ui = lon_raw_val.split('.')[0]
        deg_chars = 0
        if len(lon_parts_ui) >= 5: deg_chars = 3 # dddmm
        elif len(lon_parts_ui) >= 4: deg_chars = 2 # ddmm
        elif len(lon_parts_ui) >= 3: deg_chars = 1 # dmm
        
        if deg_chars > 0:
            lon_deg_ui = lon_raw_val[:deg_chars]
            lon_min_full_ui = lon_raw_val[deg_chars:]
            try: lon_min_formatted_ui = f"{float(lon_min_full_ui):.3f}"
            except ValueError: lon_min_formatted_ui = lon_min_full_ui
            longitude_str_temp = f"{lon_deg_ui}° {lon_min_formatted_ui}' {lon_dir}"
            ts_lon_decimal_temp = convertir_coord(lon_raw_val, lon_dir, is_longitude=True)
        
    latitude_str, longitude_str = latitude_str_temp, longitude_str_temp
    ts_lat_decimal, ts_lon_decimal = ts_lat_decimal_temp, ts_lon_decimal_temp


def parse_gga(sentence):
    global ultima_vez_datos_recibidos
    try:
        parts = sentence.split(',')
        if len(parts) > 5 and parts[2] and parts[3] and parts[4] and parts[5]:
            _actualizar_coordenadas_ui_y_ts(parts[2], parts[3], parts[4], parts[5])
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except Exception as e:
        print(f"Error parsing GGA: {sentence} - {e}")

def parse_rmc(sentence):
    global ultima_vez_datos_recibidos
    try:
        parts = sentence.split(',')
        if len(parts) > 6 and parts[3] and parts[4] and parts[5] and parts[6]: 
            _actualizar_coordenadas_ui_y_ts(parts[3], parts[4], parts[5], parts[6])
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except Exception as e:
        print(f"Error parsing RMC: {sentence} - {e}")

def parse_gll(sentence): 
    global ultima_vez_datos_recibidos
    try: 
        parts = sentence.split(',') 
        if len(parts) > 4 and parts[1] and parts[2] and parts[3] and parts[4]: 
            _actualizar_coordenadas_ui_y_ts(parts[1], parts[2], parts[3], parts[4])
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except Exception as e: 
        print(f"Error parsing GLL: {sentence} - {e}")

def parse_vtg(sentence): 
    global speed_str, ultima_vez_datos_recibidos, ts_speed_float
    try: 
        parts = sentence.split(',') 
        speed_val_str_ui = "N/A"
        temp_speed_float = 0.0

        if len(parts) > 5 and parts[5]: # Knots
            speed_val_str_ui = parts[5] 
            try: temp_speed_float = float(speed_val_str_ui)
            except (ValueError, TypeError): temp_speed_float = 0.0
        elif len(parts) > 7 and parts[7]: # Km/h (fallback)
            speed_kmh_str = parts[7]
            try:
                speed_kmh = float(speed_kmh_str)
                temp_speed_float = round(speed_kmh / 1.852, 1) # Convertir km/h a nudos
                speed_val_str_ui = str(temp_speed_float)
            except (ValueError, TypeError): pass
        
        if speed_val_str_ui != "N/A":
            speed_str = f"{speed_val_str_ui} Kt"
            ts_speed_float = temp_speed_float
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
        else:
            speed_str = "N/A Kt"
            ts_speed_float = 0.0

    except Exception as e: 
        print(f"Error parsing VTG: {sentence} - {e}")

def parse_hdt(sentence): 
    global heading_str, ultima_vez_datos_recibidos, ts_heading_float
    try: 
        parts = sentence.split(',') 
        if len(parts) > 1 and parts[1]: 
            heading_val_str = parts[1]
            try:
                heading_val_float = float(heading_val_str)
                heading_str = f"{heading_val_float:.0f}°" 
                ts_heading_float = heading_val_float      
            except (ValueError, TypeError):
                heading_str = f"{heading_val_str}°" 
                ts_heading_float = 0.0 
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except Exception as e: 
        print(f"Error parsing HDT: {sentence} - {e}")

def parse_hdg(sentence): 
    global heading_str, ultima_vez_datos_recibidos, ts_heading_float
    try: 
        parts = sentence.split(',') 
        if len(parts) > 1 and parts[1]: 
            heading_val_str = parts[1] 
            try:
                heading_val_float = float(heading_val_str)
                heading_str = f"{heading_val_float:.0f}°" 
                ts_heading_float = heading_val_float      
            except (ValueError, TypeError):
                heading_str = f"{heading_val_str}°" 
                ts_heading_float = 0.0
            ultima_vez_datos_recibidos = pygame.time.get_ticks()
    except Exception as e:
        print(f"Error parsing HDG: {sentence} - {e}")

def parse_gpzda(sentence):
    global ts_timestamp_str # No actualiza ultima_vez_datos_recibidos
    try:
        parts = sentence.split(',')
        if len(parts) >= 5: 
            time_utc_str = parts[1] 
            day_str = parts[2]; month_str = parts[3]; year_str = parts[4]

            if '.' in time_utc_str: time_utc_str = time_utc_str.split('.')[0]

            if len(time_utc_str) == 6 and day_str and month_str and year_str and len(year_str) == 4:
                h,m,s = time_utc_str[0:2], time_utc_str[2:4], time_utc_str[4:6]
                ts_timestamp_str = f"{year_str}-{month_str.zfill(2)}-{day_str.zfill(2)} {h}:{m}:{s}"
    except Exception as e:
        print(f"Error parsing GPZDA: {sentence} - {e}")
        pass 
# --- Fin NMEA Parsing Functions ---

# PI ya está definida globalmente más arriba.

dimensiones = [1050, 430] 
screen = pygame.display.set_mode(dimensiones) 
pygame.display.set_caption("Visor NMEA Avanzado") 

nuevo_ancho_area_izquierda = 750 
area_izquierda_rect = pygame.Rect(10, ALTURA_BARRA_HERRAMIENTAS + 10, nuevo_ancho_area_izquierda, dimensiones[1] - (ALTURA_BARRA_HERRAMIENTAS + 20)) 

radio_circulo_img = 78 * 2 
margen_superior_circulos = 20 
centro_y_circulos = area_izquierda_rect.top + radio_circulo_img + margen_superior_circulos 

centro_x_circulo1 = 10 + radio_circulo_img + 50 
centro_x_circulo2 = centro_x_circulo1 + (2 * radio_circulo_img) + 50

LONGITUD_MARCA_GRADO = 16 
GROSOR_MARCA_GRADO = 3   
COLOR_MARCA_GRADO = BLANCO
COLOR_ETIQUETA_GRADO = BLANCO 
RADIO_INICIO_MARCAS = radio_circulo_img 
RADIO_FIN_MARCAS = radio_circulo_img + LONGITUD_MARCA_GRADO
OFFSET_TEXTO_ETIQUETA = 20 
RADIO_POSICION_TEXTO_ETIQUETA = RADIO_FIN_MARCAS + OFFSET_TEXTO_ETIQUETA

ANGULOS_MARCAS_ETIQUETAS_DEF = {
    "0_der": (0, "0"), "0_izq": (180, "0"),    
    "sup_mas_30": (-120, "+30"), "sup_menos_30": (-60, "-30") 
}

LONGITUD_FLECHA_DIR = 20 
ANCHO_FLECHA_DIR = 12  
OFFSET_FLECHA_TEXTO = 10 
OFFSET_LETRA_ROLL_Y = 10 
COLOR_LETRA_ROLL = BLANCO 

script_dir = os.path.dirname(os.path.abspath(__file__))
ruta_imagen_fondo = os.path.join(script_dir, "mar.jpg")
try:
    imagen_fondo_original = pygame.image.load(ruta_imagen_fondo) 
    imagen_fondo_escalada = pygame.transform.scale(imagen_fondo_original, dimensiones)
    imagen_fondo_escalada = imagen_fondo_escalada.convert() 
except (pygame.error, FileNotFoundError) as e: 
    print(f"Error al cargar la imagen de fondo '{ruta_imagen_fondo}': {e}") 
    imagen_fondo_escalada = None 

pitch_image_base_grande = None 
try:
    ruta_imagen_pitch = os.path.join(script_dir, "pitch.png")
    pitch_image_surface_original_temp = pygame.image.load(ruta_imagen_pitch)
    lado_pitch_deseado_grande = int((2 * radio_circulo_img) + 2)                                                                
    pitch_image_scaled_temp = pygame.transform.smoothscale(pitch_image_surface_original_temp, (lado_pitch_deseado_grande, lado_pitch_deseado_grande))
    pitch_image_base_grande = pitch_image_scaled_temp.convert_alpha()
except (pygame.error, FileNotFoundError) as e:
    print(f"Error al cargar o escalar la imagen 'pitch.png': {e}")
    pitch_image_base_grande = None

roll_image_base_grande = None
try:
    ruta_imagen_roll = os.path.join(script_dir, "roll.png")
    roll_image_surface_original_temp = pygame.image.load(ruta_imagen_roll)
    lado_img_deseado_grande = int((2 * radio_circulo_img) + 2)                                                               
    roll_image_scaled_temp = pygame.transform.smoothscale(roll_image_surface_original_temp, (lado_img_deseado_grande, lado_img_deseado_grande))
    roll_image_base_grande = roll_image_scaled_temp.convert_alpha()
except (pygame.error, FileNotFoundError) as e:
    print(f"Error al cargar o escalar la imagen 'roll.png': {e}")
    roll_image_base_grande = None

font = pygame.font.Font(None, 24) 
font_bar_herramientas = pygame.font.Font(None, 22) 
font_datos_grandes = pygame.font.Font(None, 50) 
font_circulos_textos = pygame.font.Font(None, 72) 

texto_latitud_lon_titulo = "LAT / LON" 
texto_actitud_titulo = "CABECEO" 

reloj = pygame.time.Clock()
rect_barra_herramientas = pygame.Rect(0, 0, dimensiones[0], ALTURA_BARRA_HERRAMIENTAS)
opciones_menu_barra = ["CONFIG. PUERTO", "CONFIG. ALARM", "ACERCA DE"]
rects_opciones_menu_barra = [] 
padding_menu_x = 15 
espacio_entre_menus = 10 

hecho = False
 
init_csv() # Inicializar CSV al arrancar
ultima_vez_envio_datos = time.time() # Inicializar temporizador para ThingSpeak/CSV

while not hecho:
    for evento in pygame.event.get():  
        if evento.type == pygame.QUIT: 
            hecho = True               
        
        if evento.type == pygame.MOUSEBUTTONDOWN:
            if evento.button == 1: 
                if not mostrar_ventana_config_serial and not mostrar_ventana_acerca_de and not mostrar_ventana_alarma: 
                    if rects_opciones_menu_barra and len(rects_opciones_menu_barra) > 0 and rects_opciones_menu_barra[0].collidepoint(evento.pos): 
                        mostrar_ventana_config_serial = True
                        input_puerto_str = str(puerto) 
                        try: input_baudios_idx = lista_baudios_seleccionables.index(int(baudios))
                        except ValueError: input_baudios_idx = 0 
                        puerto_dropdown_activo = False 
                        baudios_dropdown_activo = False
                        lista_puertos_detectados.clear()
                        try:
                            ports = comports()
                            if ports:
                                for p in ports: lista_puertos_detectados.append(p.device)
                            else: lista_puertos_detectados.append("N/A") 
                        except Exception as e_com:
                            print(f"Error al detectar puertos COM: {e_com}"); lista_puertos_detectados.append("Error") 
                        if puerto not in lista_puertos_detectados and lista_puertos_detectados and lista_puertos_detectados[0] not in ["N/A", "Error"]: pass 
                    elif len(rects_opciones_menu_barra) > 1 and rects_opciones_menu_barra[1].collidepoint(evento.pos): 
                        mostrar_ventana_alarma = True
                        input_alarma_activo = None
                    elif len(rects_opciones_menu_barra) > 2 and rects_opciones_menu_barra[2].collidepoint(evento.pos): 
                        mostrar_ventana_acerca_de = True

                elif mostrar_ventana_config_serial: 
                    if puerto_dropdown_activo:
                        clic_en_item_puerto = False
                        for i, item_rect in enumerate(lista_rects_items_puerto):
                            if item_rect.collidepoint(evento.pos):
                                input_puerto_str = lista_puertos_detectados[i]; puerto_dropdown_activo = False; clic_en_item_puerto = True; break
                        if not clic_en_item_puerto and not rect_input_puerto_config.collidepoint(evento.pos): puerto_dropdown_activo = False 
                    elif rect_input_puerto_config.collidepoint(evento.pos): 
                        puerto_dropdown_activo = not puerto_dropdown_activo
                        if puerto_dropdown_activo: baudios_dropdown_activo = False 
                    elif baudios_dropdown_activo:
                        clic_en_item_baudios = False
                        for i, item_rect in enumerate(lista_rects_items_baudios):
                            if item_rect.collidepoint(evento.pos):
                                input_baudios_idx = i; baudios_dropdown_activo = False; clic_en_item_baudios = True; break
                        if not clic_en_item_baudios and not rect_input_baudios_display_config.collidepoint(evento.pos): baudios_dropdown_activo = False
                    elif rect_input_baudios_display_config.collidepoint(evento.pos): 
                        baudios_dropdown_activo = not baudios_dropdown_activo
                        if baudios_dropdown_activo: puerto_dropdown_activo = False 
                    elif rect_boton_cerrar_config.collidepoint(evento.pos):
                        mostrar_ventana_config_serial = False; puerto_dropdown_activo = False; baudios_dropdown_activo = False
                    elif rect_boton_guardar_config.collidepoint(evento.pos): 
                        nuevos_baudios = lista_baudios_seleccionables[input_baudios_idx]
                        guardar_configuracion_serial(input_puerto_str, nuevos_baudios)
                        puerto = input_puerto_str; baudios = nuevos_baudios
                        print(f"Aplicando nueva configuración: Puerto={puerto}, Baudios={baudios}")
                        if ser and ser.is_open: ser.close()
                        try:
                            ser = serial.Serial(puerto, baudios); serial_port_available = True
                            print(f"Puerto serial {puerto} reabierto con {baudios} baudios.")
                        except serial.SerialException as e:
                            print(f"Error reabriendo puerto serial {puerto} con {baudios} baud: {e}"); serial_port_available = False
                        except Exception as e:
                            print(f"Error inesperado reabriendo puerto: {e}"); serial_port_available = False
                        mostrar_ventana_config_serial = False; puerto_dropdown_activo = False
                    else: puerto_dropdown_activo = False
                
                elif mostrar_ventana_alarma:
                    if rect_boton_salir_alarma and rect_boton_salir_alarma.collidepoint(evento.pos):
                        mostrar_ventana_alarma = False; input_alarma_activo = None
                    elif rect_boton_guardar_alarma and rect_boton_guardar_alarma.collidepoint(evento.pos):
                        valido = True
                        try:
                            if not (5 <= int(valores_alarma["max_pitch_pos"]) <= 30): valido = False; print("Error: Max Pitch +")
                            if not (-30 <= int(valores_alarma["min_pitch_neg"]) <= -5): valido = False; print("Error: Min Pitch -")
                            if not (5 <= int(valores_alarma["max_roll_pos"]) <= 30): valido = False; print("Error: Max Roll +")
                            if not (-30 <= int(valores_alarma["min_roll_neg"]) <= -5): valido = False; print("Error: Min Roll -")
                        except ValueError: valido = False; print("Error: Valores no numéricos")
                        if valido:
                            guardar_configuracion_alarma(); mostrar_ventana_alarma = False; input_alarma_activo = None
                            print("Configuración de alarma guardada.")
                        else: print("No se guardó config de alarma.")
                    elif rect_input_max_pitch_pos and rect_input_max_pitch_pos.collidepoint(evento.pos): input_alarma_activo = "max_pitch_pos"
                    elif rect_input_min_pitch_neg and rect_input_min_pitch_neg.collidepoint(evento.pos): input_alarma_activo = "min_pitch_neg"
                    elif rect_input_max_roll_pos and rect_input_max_roll_pos.collidepoint(evento.pos): input_alarma_activo = "max_roll_pos"
                    elif rect_input_min_roll_neg and rect_input_min_roll_neg.collidepoint(evento.pos): input_alarma_activo = "min_roll_neg"
                    else: input_alarma_activo = None
                
                elif mostrar_ventana_acerca_de:
                    if rect_boton_cerrar_acerca_de and rect_boton_cerrar_acerca_de.collidepoint(evento.pos):
                         mostrar_ventana_acerca_de = False

        if evento.type == pygame.KEYDOWN:
            if mostrar_ventana_config_serial: 
                if evento.key == pygame.K_ESCAPE: mostrar_ventana_config_serial = False; puerto_dropdown_activo = False
            elif mostrar_ventana_alarma: 
                if evento.key == pygame.K_ESCAPE: mostrar_ventana_alarma = False; input_alarma_activo = None
                elif input_alarma_activo: 
                    if evento.key == pygame.K_BACKSPACE: valores_alarma[input_alarma_activo] = valores_alarma[input_alarma_activo][:-1]
                    elif evento.unicode.isdigit() or (evento.unicode == '-' and not valores_alarma[input_alarma_activo]) or (evento.unicode == '.' and '.' not in valores_alarma[input_alarma_activo]):
                        valores_alarma[input_alarma_activo] += evento.unicode
            elif mostrar_ventana_acerca_de: 
                if evento.key == pygame.K_ESCAPE: mostrar_ventana_acerca_de = False

    if not serial_port_available and not mostrar_ventana_config_serial and not mostrar_ventana_alarma and not mostrar_ventana_acerca_de: 
        ahora = pygame.time.get_ticks()
        if ahora - ultimo_intento_reconeccion_tiempo > INTERVALO_RECONECCION_MS:
            print(f"Intentando reconectar al puerto {puerto} con {baudios} baudios...")
            ultimo_intento_reconeccion_tiempo = ahora
            try:
                if ser and ser.is_open: ser.close()
                ser = serial.Serial(puerto, baudios); serial_port_available = True
                print(f"Reconexión exitosa al puerto {puerto}.")
            except serial.SerialException as e_reconect: 
                print(f"Fallo al reconectar: {e_reconect}"); ser = None; serial_port_available = False 
            except Exception as e_reconect_general: 
                print(f"Error inesperado reconexión: {e_reconect_general}"); ser = None; serial_port_available = False

    if serial_port_available and ser and ser.is_open: 
        try:
            if ser.in_waiting > 0: 
                line = ser.readline().decode('ascii', errors='replace').strip()
                if line.startswith('$GPGLL') or line.startswith('$GNGLL'): parse_gll(line)
                elif line.startswith('$GPGGA') or line.startswith('$GNGGA'): parse_gga(line) 
                elif line.startswith('$GPRMC') or line.startswith('$GNRMC'): parse_rmc(line) 
                elif line.startswith('$GPVTG') or line.startswith('$GNVTG'): parse_vtg(line)
                elif line.startswith('$GPHDT') or line.startswith('$GNHDT'): parse_hdt(line)
                elif line.startswith('$GPHDG') or line.startswith('$GNHDG'): parse_hdg(line)
                elif line.startswith('$PFEC,GPatt'): parse_pfec_gpatt(line)
                elif line.startswith('$GPZDA') or line.startswith('$GNZDA'): parse_gpzda(line) # Llamada a parse_gpzda
        except serial.SerialException as se:
            print(f"SerialException lectura: {se}. Puerto desconectado."); ser.close(); ser = None; serial_port_available = False 
            ultimo_intento_reconeccion_tiempo = pygame.time.get_ticks() 
        except Exception as e:
            print(f"Error parseo datos seriales: {e}") 
    
    # Lógica para enviar datos a ThingSpeak y CSV cada INTERVALO_ENVIO_DATOS_S
    if time.time() - ultima_vez_envio_datos >= INTERVALO_ENVIO_DATOS_S:
        if serial_port_available : 
            estado_alarma_para_print = obtener_estado_alarma_actual() # Obtener estado de alarma
            print(f"--- Guardando y Enviando Datos ({time.strftime('%Y-%m-%d %H:%M:%S')}) ---")
            # Actualizar el print para incluir el estado de la alarma
            print(f"Valores: P:{ts_pitch_float}, R:{ts_roll_float}, Lat:{ts_lat_decimal}, Lon:{ts_lon_decimal}, Spd:{ts_speed_float}, Hdg:{ts_heading_float}, TS:{ts_timestamp_str}, Alarma: {estado_alarma_para_print}")
            guardar_csv()
            enviar_thingspeak() # Activado el envío a ThingSpeak
            print("---------------------------------------------------\n")
        ultima_vez_envio_datos = time.time()

    # --- Lógica de Comprobación de Alarmas de Roll ---
    if att_roll_str != "N/A" and valores_alarma: # Solo si tenemos valor de roll y configuración de alarma
        try:
            current_roll_float = ts_roll_float # Usar el valor float ya parseado
            
            umbral_min_roll = int(valores_alarma["min_roll_neg"]) # ej. -15
            umbral_max_roll = int(valores_alarma["max_roll_pos"]) # ej. +15

            ahora = time.time() # Obtener tiempo actual para la lógica de repetición

            # Alarma de Babor (Roll Negativo Excesivo)
            if current_roll_float < umbral_min_roll: 
                if not alarma_roll_babor_activa: # Si la condición recién se activa
                    print(f"CONDICIÓN ALARMA BABOR INICIADA: Roll {current_roll_float}° < {umbral_min_roll}°")
                    # ultima_reproduccion_alarma_babor_tiempo se mantiene en 0 o su valor anterior, 
                    # el gestor de sonido decidirá si suena de inmediato o tras intervalo.
                alarma_roll_babor_activa = True
            else: 
                if alarma_roll_babor_activa: # Si la condición estaba activa y ahora no lo está
                    print(f"CONDICIÓN ALARMA BABOR CESADA: Roll {current_roll_float}° >= {umbral_min_roll}°")
                    alarma_roll_babor_activa = False
                    ultima_reproduccion_alarma_babor_tiempo = 0 # Resetear para que suene inmediatamente la próxima vez

            # Alarma de Estribor (Roll Positivo Excesivo)
            if current_roll_float > umbral_max_roll: 
                if not alarma_roll_estribor_activa:
                    print(f"CONDICIÓN ALARMA ESTRIBOR INICIADA: Roll {current_roll_float}° > {umbral_max_roll}°")
                alarma_roll_estribor_activa = True
            else: 
                if alarma_roll_estribor_activa: 
                    print(f"CONDICIÓN ALARMA ESTRIBOR CESADA: Roll {current_roll_float}° <= {umbral_max_roll}°")
                    alarma_roll_estribor_activa = False
                    ultima_reproduccion_alarma_estribor_tiempo = 0
                
        except (ValueError, KeyError) as e:
            print(f"Error al procesar valores de alarma o roll: {e}")
            # Resetear estados de alarma de roll en caso de error con los umbrales
            alarma_roll_babor_activa = False
            alarma_roll_estribor_activa = False
            # No detenemos sonidos aquí, el gestor de sonido lo hará si no hay condiciones activas
            
    # --- Lógica de Comprobación de Alarmas de Pitch ---
    # 'ahora' ya está definido arriba si la lógica de Roll se ejecutó.
    # Si no, lo definimos aquí. Es mejor definir 'ahora = time.time()' una sola vez al inicio de la sección de alarmas.
    # (Se asume que 'ahora' de la sección de Roll está disponible o se recalcula en el gestor de sonido)

    if att_pitch_str != "N/A" and valores_alarma: 
        try:
            current_pitch_float = ts_pitch_float 
            umbral_min_pitch = int(valores_alarma["min_pitch_neg"]) 
            umbral_max_pitch = int(valores_alarma["max_pitch_pos"]) 

            # Alarma de Encabuzado (Pitch Negativo Excesivo)
            if current_pitch_float < umbral_min_pitch:
                if not alarma_pitch_encabuzado_activa:
                     print(f"CONDICIÓN ALARMA ENCABUZADO INICIADA: Pitch {current_pitch_float}° < {umbral_min_pitch}°")
                alarma_pitch_encabuzado_activa = True
            else: 
                if alarma_pitch_encabuzado_activa:
                    print(f"CONDICIÓN ALARMA ENCABUZADO CESADA: Pitch {current_pitch_float}° >= {umbral_min_pitch}°")
                    alarma_pitch_encabuzado_activa = False
                    ultima_reproduccion_alarma_encabuzado_tiempo = 0 

            # Alarma de Sentado (Pitch Positivo Excesivo)
            if current_pitch_float > umbral_max_pitch:
                if not alarma_pitch_sentado_activa:
                    print(f"CONDICIÓN ALARMA SENTADO INICIADA: Pitch {current_pitch_float}° > {umbral_max_pitch}°")
                alarma_pitch_sentado_activa = True
            else: 
                if alarma_pitch_sentado_activa:
                    print(f"CONDICIÓN ALARMA SENTADO CESADA: Pitch {current_pitch_float}° <= {umbral_max_pitch}°")
                    alarma_pitch_sentado_activa = False
                    ultima_reproduccion_alarma_sentado_tiempo = 0

        except (ValueError, KeyError) as e:
            print(f"Error al procesar valores de alarma o pitch: {e}")
            alarma_pitch_sentado_activa = False
            alarma_pitch_encabuzado_activa = False

# Lógica para enviar datos a ThingSpeak y CSV cada INTERVALO_ENVIO_DATOS_S
    if time.time() - ultima_vez_envio_datos >= INTERVALO_ENVIO_DATOS_S:
        if serial_port_available : 
            estado_alarma_para_print = obtener_estado_alarma_actual() # Obtener estado de alarma
            print(f"--- Guardando y Enviando Datos ({time.strftime('%Y-%m-%d %H:%M:%S')}) ---")
            # Actualizar el print para incluir el estado de la alarma
            print(f"Valores: P:{ts_pitch_float}, R:{ts_roll_float}, Lat:{ts_lat_decimal}, Lon:{ts_lon_decimal}, Spd:{ts_speed_float}, Hdg:{ts_heading_float}, TS:{ts_timestamp_str}, Alarma: {estado_alarma_para_print}")
            guardar_csv()
            enviar_thingspeak() # Activado el envío a ThingSpeak
            print("---------------------------------------------------\n")
        ultima_vez_envio_datos = time.time()

    # --- INICIO SECCIÓN DE LÓGICA DE ALARMAS ---
    ahora = time.time() # Tiempo actual para todas las decisiones de alarma

    # --- Lógica de Comprobación de Condiciones de Alarma de Roll ---
    if att_roll_str != "N/A" and valores_alarma:
        try:
            current_roll_float = ts_roll_float
            umbral_min_roll = int(valores_alarma["min_roll_neg"])
            umbral_max_roll = int(valores_alarma["max_roll_pos"])

            if current_roll_float < umbral_min_roll: 
                if not alarma_roll_babor_activa:
                    # print(f"CONDICIÓN ALARMA BABOR INICIADA: Roll {current_roll_float}° < {umbral_min_roll}°") # DEBUG
                    pass
                alarma_roll_babor_activa = True
            else: 
                if alarma_roll_babor_activa:
                    # print(f"CONDICIÓN ALARMA BABOR CESADA: Roll {current_roll_float}° >= {umbral_min_roll}°") # DEBUG
                    alarma_roll_babor_activa = False
                    ultima_reproduccion_alarma_babor_tiempo = 0 

            if current_roll_float > umbral_max_roll: 
                if not alarma_roll_estribor_activa:
                    # print(f"CONDICIÓN ALARMA ESTRIBOR INICIADA: Roll {current_roll_float}° > {umbral_max_roll}°") # DEBUG
                    pass
                alarma_roll_estribor_activa = True
            else: 
                if alarma_roll_estribor_activa: 
                    # print(f"CONDICIÓN ALARMA ESTRIBOR CESADA: Roll {current_roll_float}° <= {umbral_max_roll}°") # DEBUG
                    alarma_roll_estribor_activa = False
                    ultima_reproduccion_alarma_estribor_tiempo = 0
                
        except (ValueError, KeyError) as e:
            print(f"Error al procesar valores de alarma o roll: {e}")
            alarma_roll_babor_activa = False
            alarma_roll_estribor_activa = False
            
    # --- Lógica de Comprobación de Condiciones de Alarma de Pitch ---
    if att_pitch_str != "N/A" and valores_alarma: 
        try:
            current_pitch_float = ts_pitch_float 
            umbral_min_pitch = int(valores_alarma["min_pitch_neg"]) 
            umbral_max_pitch = int(valores_alarma["max_pitch_pos"]) 

            if current_pitch_float < umbral_min_pitch:
                if not alarma_pitch_encabuzado_activa:
                    # print(f"CONDICIÓN ALARMA ENCABUZADO INICIADA: Pitch {current_pitch_float}° < {umbral_min_pitch}°") # DEBUG
                    pass
                alarma_pitch_encabuzado_activa = True
            else: 
                if alarma_pitch_encabuzado_activa:
                    # print(f"CONDICIÓN ALARMA ENCABUZADO CESADA: Pitch {current_pitch_float}° >= {umbral_min_pitch}°") # DEBUG
                    alarma_pitch_encabuzado_activa = False
                    ultima_reproduccion_alarma_encabuzado_tiempo = 0 

            if current_pitch_float > umbral_max_pitch:
                if not alarma_pitch_sentado_activa:
                    # print(f"CONDICIÓN ALARMA SENTADO INICIADA: Pitch {current_pitch_float}° > {umbral_max_pitch}°") # DEBUG
                    pass
                alarma_pitch_sentado_activa = True
            else: 
                if alarma_pitch_sentado_activa:
                    # print(f"CONDICIÓN ALARMA SENTADO CESADA: Pitch {current_pitch_float}° <= {umbral_max_pitch}°") # DEBUG
                    alarma_pitch_sentado_activa = False
                    ultima_reproduccion_alarma_sentado_tiempo = 0

        except (ValueError, KeyError) as e:
            print(f"Error al procesar valores de alarma o pitch: {e}")
            alarma_pitch_sentado_activa = False
            alarma_pitch_encabuzado_activa = False

    # --- NUEVO GESTOR DE SONIDO DE ALARMA ALTERNADO ---
    # print(f"DEBUG GESTOR: ahora={ahora:.2f}") # DEBUG GENERAL
    alarmas_condiciones_activas_info = [] 
    if alarma_roll_babor_activa and sonido_alarma_babor:
        alarmas_condiciones_activas_info.append({'id': 'roll_babor', 'sonido': sonido_alarma_babor, 'tiempo_var_name': 'ultima_reproduccion_alarma_babor_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_ROLL_S, 'mensaje': f"ALARMA BABOR (Roll {ts_roll_float}°)"})
    if alarma_roll_estribor_activa and sonido_alarma_estribor:
        alarmas_condiciones_activas_info.append({'id': 'roll_estribor', 'sonido': sonido_alarma_estribor, 'tiempo_var_name': 'ultima_reproduccion_alarma_estribor_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_ROLL_S, 'mensaje': f"ALARMA ESTRIBOR (Roll {ts_roll_float}°)"})
    if alarma_pitch_sentado_activa and sonido_alarma_sentado:
        alarmas_condiciones_activas_info.append({'id': 'pitch_sentado', 'sonido': sonido_alarma_sentado, 'tiempo_var_name': 'ultima_reproduccion_alarma_sentado_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_PITCH_S, 'mensaje': f"ALARMA SENTADO (Pitch {ts_pitch_float}°)"})
    if alarma_pitch_encabuzado_activa and sonido_alarma_encabuzado:
        alarmas_condiciones_activas_info.append({'id': 'pitch_encabuzado', 'sonido': sonido_alarma_encabuzado, 'tiempo_var_name': 'ultima_reproduccion_alarma_encabuzado_tiempo', 'intervalo': INTERVALO_REPETICION_ALARMA_PITCH_S, 'mensaje': f"ALARMA ENCABUZADO (Pitch {ts_pitch_float}°)"})

    # print(f"DEBUG GESTOR: Condiciones activas detectadas: {len(alarmas_condiciones_activas_info)}") # DEBUG
    # for al_info_debug in alarmas_condiciones_activas_info: # DEBUG
    #    print(f"  DEBUG ACTIVA DETECTADA: {al_info_debug['id']}") # DEBUG

    alarmas_listas_para_sonar_info = []
    for alarma_info in alarmas_condiciones_activas_info:
        if ahora - globals()[alarma_info['tiempo_var_name']] >= alarma_info['intervalo']:
            alarmas_listas_para_sonar_info.append(alarma_info)
            # print(f"  DEBUG ALARMA LISTA PARA SONAR: {alarma_info['id']} (Ultima reprod: {globals()[alarma_info['tiempo_var_name']]:.2f}, Intervalo: {alarma_info['intervalo']})") # DEBUG
    # print(f"DEBUG GESTOR: Alarmas listas para sonar: {len(alarmas_listas_para_sonar_info)}") # DEBUG
            
    if not alarmas_condiciones_activas_info: 
        if sonido_alarma_actualmente_reproduciendo is not None:
            print(f"GESTORSND DEBUG: Todas condiciones cesaron. Deteniendo {sonido_alarma_actualmente_reproduciendo}.")
            sonido_alarma_actualmente_reproduciendo.stop()
            sonido_alarma_actualmente_reproduciendo = None
            INDICE_PROXIMA_ALARMA_A_SONAR = 0 
            # Resetear todos los temporizadores individuales ya que ninguna condición está activa
            # Esto ya se hace cuando la condición individual cesa, pero por si acaso.
            ultima_reproduccion_alarma_babor_tiempo = 0.0
            ultima_reproduccion_alarma_estribor_tiempo = 0.0
            ultima_reproduccion_alarma_sentado_tiempo = 0.0
            ultima_reproduccion_alarma_encabuzado_tiempo = 0.0
            
    elif alarmas_listas_para_sonar_info: 
        sonido_actual_ha_terminado_o_pausa_cumplida = True
        if sonido_alarma_actualmente_reproduciendo is not None:
            duracion_sonido_actual = 0
            try: 
                duracion_sonido_actual = sonido_alarma_actualmente_reproduciendo.get_length()
            except pygame.error: 
                sonido_alarma_actualmente_reproduciendo = None 

            if sonido_alarma_actualmente_reproduciendo is not None and \
               (ahora < tiempo_ultimo_sonido_iniciado + duracion_sonido_actual + PAUSA_ENTRE_SONIDOS_ALTERNADOS_S):
                sonido_actual_ha_terminado_o_pausa_cumplida = False
        
        # print(f"DEBUG GESTOR: sonido_actual_terminado_o_pausa_cumplida = {sonido_actual_ha_terminado_o_pausa_cumplida}") # DEBUG

        if sonido_actual_ha_terminado_o_pausa_cumplida:
            if INDICE_PROXIMA_ALARMA_A_SONAR >= len(alarmas_listas_para_sonar_info):
                INDICE_PROXIMA_ALARMA_A_SONAR = 0
                
            alarma_a_reproducir_info = alarmas_listas_para_sonar_info[INDICE_PROXIMA_ALARMA_A_SONAR]
            
            if sonido_alarma_actualmente_reproduciendo is not None and sonido_alarma_actualmente_reproduciendo != alarma_a_reproducir_info['sonido']:
                print(f"GESTORSND DEBUG: Cambiando. Deteniendo sonido anterior.")
                sonido_alarma_actualmente_reproduciendo.stop()

            print(f"GESTORSND DEBUG: INTENTANDO REPRODUCIR {alarma_a_reproducir_info['mensaje']}")
            alarma_a_reproducir_info['sonido'].play()

            sonido_alarma_actualmente_reproduciendo = alarma_a_reproducir_info['sonido']
            tiempo_ultimo_sonido_iniciado = ahora
            globals()[alarma_a_reproducir_info['tiempo_var_name']] = ahora 
            
            INDICE_PROXIMA_ALARMA_A_SONAR = (INDICE_PROXIMA_ALARMA_A_SONAR + 1) 
    # --- FIN NUEVO GESTOR DE SONIDO ---


    if imagen_fondo_escalada: screen.blit(imagen_fondo_escalada, (0, 0))
    else: screen.fill(AZUL) 

    pygame.draw.rect(screen, COLOR_BARRA_HERRAMIENTAS_FONDO, rect_barra_herramientas)
    pygame.draw.rect(screen, COLOR_BARRA_HERRAMIENTAS_BORDE, rect_barra_herramientas, 1) 
    rects_opciones_menu_barra.clear() 
    current_x_menu_draw = padding_menu_x
    for opcion_texto in opciones_menu_barra:
        texto_surf = font_bar_herramientas.render(opcion_texto, True, COLOR_ITEM_MENU_TEXTO)
        texto_rect = texto_surf.get_rect(left=current_x_menu_draw, centery=rect_barra_herramientas.centery)
        clickable_rect = texto_rect.inflate(padding_menu_x * 2, ALTURA_BARRA_HERRAMIENTAS // 3) 
        clickable_rect.centery = rect_barra_herramientas.centery 
        rects_opciones_menu_barra.append(clickable_rect) 
        screen.blit(texto_surf, texto_rect)
        current_x_menu_draw += texto_rect.width + espacio_entre_menus + padding_menu_x 

    if mostrar_ventana_config_serial:
        pygame.draw.rect(screen, COLOR_VENTANA_FONDO, rect_ventana_config) 
        pygame.draw.rect(screen, COLOR_BORDE_VENTANA, rect_ventana_config, 2) 
        titulo_surf = font.render("Configuración Puerto Serie", True, COLOR_TEXTO_NORMAL)
        screen.blit(titulo_surf, (rect_ventana_config.centerx - titulo_surf.get_width() // 2, rect_ventana_config.top + 15))
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_cerrar_config)
        pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_cerrar_config, 1)
        cerrar_text = font.render("X", True, COLOR_TEXTO_NORMAL)
        screen.blit(cerrar_text, cerrar_text.get_rect(center=rect_boton_cerrar_config.center))
        label_puerto_surf = font.render("Puerto:", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_puerto_surf, (rect_ventana_config.left + 20, rect_input_puerto_config.centery - label_puerto_surf.get_height()//2))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO, rect_input_puerto_config, 0) 
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_puerto_config, 1) 
        input_puerto_surf = font.render(input_puerto_str, True, COLOR_TEXTO_NORMAL)
        screen.blit(input_puerto_surf, (rect_input_puerto_config.left + 5, rect_input_puerto_config.centery - input_puerto_surf.get_height() // 2))
        pygame.draw.polygon(screen, COLOR_TEXTO_NORMAL, [(rect_input_puerto_config.right - 15, rect_input_puerto_config.centery - 3),(rect_input_puerto_config.right - 5, rect_input_puerto_config.centery - 3),(rect_input_puerto_config.right - 10, rect_input_puerto_config.centery + 3)])
        if puerto_dropdown_activo:
            lista_rects_items_puerto.clear()
            item_height = input_puerto_surf.get_height() + 4 
            dropdown_height = min(item_height * len(lista_puertos_detectados), rect_ventana_config.height - (rect_input_puerto_config.bottom - rect_ventana_config.top) - 10)
            rect_lista_puertos_desplegable = pygame.Rect(rect_input_puerto_config.left, rect_input_puerto_config.bottom, rect_input_puerto_config.width, dropdown_height)
            pygame.draw.rect(screen, COLOR_DROPDOWN_FONDO, rect_lista_puertos_desplegable) 
            pygame.draw.rect(screen, COLOR_DROPDOWN_BORDE, rect_lista_puertos_desplegable, 1) 
            for i, port_name in enumerate(lista_puertos_detectados):
                item_rect = pygame.Rect(rect_lista_puertos_desplegable.left, rect_lista_puertos_desplegable.top + i * item_height, rect_lista_puertos_desplegable.width, item_height)
                if item_rect.bottom > rect_lista_puertos_desplegable.bottom: break
                lista_rects_items_puerto.append(item_rect)
                item_surf = font.render(port_name, True, COLOR_TEXTO_NORMAL)
                screen.blit(item_surf, (item_rect.left + 5, item_rect.centery - item_surf.get_height() // 2))
        label_baudios_surf = font.render("Baudios:", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_baudios_surf, (rect_ventana_config.left + 20, rect_input_baudios_display_config.centery - label_baudios_surf.get_height()//2))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO, rect_input_baudios_display_config, 0) 
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_baudios_display_config, 1) 
        baudios_surf = font.render(str(lista_baudios_seleccionables[input_baudios_idx]), True, COLOR_TEXTO_NORMAL)
        screen.blit(baudios_surf, baudios_surf.get_rect(center=rect_input_baudios_display_config.center))
        pygame.draw.polygon(screen, COLOR_TEXTO_NORMAL, [(rect_input_baudios_display_config.right - 15, rect_input_baudios_display_config.centery - 3),(rect_input_baudios_display_config.right - 5, rect_input_baudios_display_config.centery - 3),(rect_input_baudios_display_config.right - 10, rect_input_baudios_display_config.centery + 3)])
        if baudios_dropdown_activo:
            lista_rects_items_baudios.clear()
            item_height = baudios_surf.get_height() + 4
            dropdown_height = min(item_height * len(lista_baudios_seleccionables), rect_ventana_config.height - (rect_input_baudios_display_config.bottom - rect_ventana_config.top) - 10)
            rect_lista_baudios_desplegable = pygame.Rect(rect_input_baudios_display_config.left, rect_input_baudios_display_config.bottom, rect_input_baudios_display_config.width, dropdown_height)
            pygame.draw.rect(screen, COLOR_DROPDOWN_FONDO, rect_lista_baudios_desplegable)
            pygame.draw.rect(screen, COLOR_DROPDOWN_BORDE, rect_lista_baudios_desplegable, 1)
            for i, baud_rate in enumerate(lista_baudios_seleccionables):
                item_rect = pygame.Rect(rect_lista_baudios_desplegable.left, rect_lista_baudios_desplegable.top + i * item_height, rect_lista_baudios_desplegable.width, item_height)
                if item_rect.bottom > rect_lista_baudios_desplegable.bottom: break
                lista_rects_items_baudios.append(item_rect)
                item_surf = font.render(str(baud_rate), True, COLOR_TEXTO_NORMAL)
                screen.blit(item_surf, (item_rect.left + 5, item_rect.centery - item_surf.get_height() // 2))
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_guardar_config)
        pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_guardar_config, 1)
        guardar_surf = font.render("Guardar y Aplicar", True, COLOR_TEXTO_NORMAL)
        screen.blit(guardar_surf, guardar_surf.get_rect(center=rect_boton_guardar_config.center))

    elif mostrar_ventana_alarma:
        pygame.draw.rect(screen, COLOR_VENTANA_FONDO, rect_ventana_alarma)
        pygame.draw.rect(screen, COLOR_BORDE_VENTANA, rect_ventana_alarma, 2)
        titulo_alarma_surf = font.render("Configuración de Alarmas", True, COLOR_TEXTO_NORMAL)
        screen.blit(titulo_alarma_surf, (rect_ventana_alarma.centerx - titulo_alarma_surf.get_width() // 2, rect_ventana_alarma.top + 15))
        y_start_inputs = rect_ventana_alarma.top + 60; input_height = 30; label_width = 180; input_width = 100; padding_y = 15
        rect_label_max_pitch_pos = pygame.Rect(rect_ventana_alarma.left + 20, y_start_inputs, label_width, input_height)
        rect_input_max_pitch_pos = pygame.Rect(rect_label_max_pitch_pos.right + 10, y_start_inputs, input_width, input_height)
        label_max_pitch_surf = font.render("Max Pitch + (5 a 30):", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_max_pitch_surf, label_max_pitch_surf.get_rect(centery=rect_label_max_pitch_pos.centery, left=rect_label_max_pitch_pos.left))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO if input_alarma_activo != "max_pitch_pos" else pygame.Color('lightskyblue1'), rect_input_max_pitch_pos)
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_max_pitch_pos, 1)
        input_max_pitch_surf = font.render(valores_alarma["max_pitch_pos"], True, COLOR_TEXTO_NORMAL)
        screen.blit(input_max_pitch_surf, (rect_input_max_pitch_pos.left + 5, rect_input_max_pitch_pos.centery - input_max_pitch_surf.get_height() // 2))
        y_current = y_start_inputs + input_height + padding_y
        rect_label_min_pitch_neg = pygame.Rect(rect_ventana_alarma.left + 20, y_current, label_width, input_height)
        rect_input_min_pitch_neg = pygame.Rect(rect_label_min_pitch_neg.right + 10, y_current, input_width, input_height)
        label_min_pitch_surf = font.render("Min Pitch - (-5 a -30):", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_min_pitch_surf, label_min_pitch_surf.get_rect(centery=rect_label_min_pitch_neg.centery, left=rect_label_min_pitch_neg.left))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO if input_alarma_activo != "min_pitch_neg" else pygame.Color('lightskyblue1'), rect_input_min_pitch_neg)
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_min_pitch_neg, 1)
        input_min_pitch_surf = font.render(valores_alarma["min_pitch_neg"], True, COLOR_TEXTO_NORMAL)
        screen.blit(input_min_pitch_surf, (rect_input_min_pitch_neg.left + 5, rect_input_min_pitch_neg.centery - input_min_pitch_surf.get_height() // 2))
        y_current += input_height + padding_y
        rect_label_max_roll_pos = pygame.Rect(rect_ventana_alarma.left + 20, y_current, label_width, input_height)
        rect_input_max_roll_pos = pygame.Rect(rect_label_max_roll_pos.right + 10, y_current, input_width, input_height)
        label_max_roll_surf = font.render("Max Roll + (5 a 30):", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_max_roll_surf, label_max_roll_surf.get_rect(centery=rect_label_max_roll_pos.centery, left=rect_label_max_roll_pos.left))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO if input_alarma_activo != "max_roll_pos" else pygame.Color('lightskyblue1'), rect_input_max_roll_pos)
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_max_roll_pos, 1)
        input_max_roll_surf = font.render(valores_alarma["max_roll_pos"], True, COLOR_TEXTO_NORMAL)
        screen.blit(input_max_roll_surf, (rect_input_max_roll_pos.left + 5, rect_input_max_roll_pos.centery - input_max_roll_surf.get_height() // 2))
        y_current += input_height + padding_y
        rect_label_min_roll_neg = pygame.Rect(rect_ventana_alarma.left + 20, y_current, label_width, input_height)
        rect_input_min_roll_neg = pygame.Rect(rect_label_min_roll_neg.right + 10, y_current, input_width, input_height)
        label_min_roll_surf = font.render("Min Roll - (-5 a -30):", True, COLOR_TEXTO_NORMAL)
        screen.blit(label_min_roll_surf, label_min_roll_surf.get_rect(centery=rect_label_min_roll_neg.centery, left=rect_label_min_roll_neg.left))
        pygame.draw.rect(screen, COLOR_INPUT_FONDO if input_alarma_activo != "min_roll_neg" else pygame.Color('lightskyblue1'), rect_input_min_roll_neg)
        pygame.draw.rect(screen, COLOR_INPUT_BORDE, rect_input_min_roll_neg, 1)
        input_min_roll_surf = font.render(valores_alarma["min_roll_neg"], True, COLOR_TEXTO_NORMAL)
        screen.blit(input_min_roll_surf, (rect_input_min_roll_neg.left + 5, rect_input_min_roll_neg.centery - input_min_roll_surf.get_height() // 2))
        button_width = 120; button_height = 40
        rect_boton_guardar_alarma = pygame.Rect(rect_ventana_alarma.centerx - button_width - 10, rect_ventana_alarma.bottom - 60, button_width, button_height)
        rect_boton_salir_alarma = pygame.Rect(rect_ventana_alarma.centerx + 10, rect_ventana_alarma.bottom - 60, button_width, button_height)
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_guardar_alarma)
        pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_guardar_alarma, 1)
        guardar_alarma_surf = font.render("Guardar", True, COLOR_TEXTO_NORMAL)
        screen.blit(guardar_alarma_surf, guardar_alarma_surf.get_rect(center=rect_boton_guardar_alarma.center))
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_salir_alarma)
        pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_salir_alarma, 1)
        salir_alarma_surf = font.render("Salir", True, COLOR_TEXTO_NORMAL)
        screen.blit(salir_alarma_surf, salir_alarma_surf.get_rect(center=rect_boton_salir_alarma.center))

    elif mostrar_ventana_acerca_de:
        rect_ventana_acerca_de = pygame.Rect(250, 150, 400, 250) 
        pygame.draw.rect(screen, COLOR_VENTANA_FONDO, rect_ventana_acerca_de)
        pygame.draw.rect(screen, COLOR_BORDE_VENTANA, rect_ventana_acerca_de, 2)
        titulo_acerca_surf = font.render("Acerca de Cabeceo Alarm", True, COLOR_TEXTO_NORMAL)
        screen.blit(titulo_acerca_surf, (rect_ventana_acerca_de.centerx - titulo_acerca_surf.get_width() // 2, rect_ventana_acerca_de.top + 15))
        texto_info = ["Programa: Cabeceo Alarm", "Versión: 1.0", "Realizado por: Hdelacruz", "Email: hugo_delacruz@hotmail.com"]
        y_offset_info = rect_ventana_acerca_de.top + 60
        for linea in texto_info:
            info_surf = font.render(linea, True, COLOR_TEXTO_NORMAL)
            screen.blit(info_surf, (rect_ventana_acerca_de.left + 20, y_offset_info))
            y_offset_info += info_surf.get_height() + 10 
        rect_boton_cerrar_acerca_de = pygame.Rect(rect_ventana_acerca_de.centerx - 50, rect_ventana_acerca_de.bottom - 50, 100, 30)
        pygame.draw.rect(screen, COLOR_BOTON_FONDO, rect_boton_cerrar_acerca_de)
        pygame.draw.rect(screen, COLOR_BOTON_BORDE, rect_boton_cerrar_acerca_de, 1)
        cerrar_acerca_surf = font.render("Cerrar", True, COLOR_TEXTO_NORMAL)
        screen.blit(cerrar_acerca_surf, cerrar_acerca_surf.get_rect(center=rect_boton_cerrar_acerca_de.center))
        
    else: 
        pygame.draw.circle(screen, BLANCO, (centro_x_circulo1, centro_y_circulos), radio_circulo_img, 2)
        pygame.draw.circle(screen, BLANCO, (centro_x_circulo2, centro_y_circulos), radio_circulo_img, 2)

        if pitch_image_base_grande: 
            try:
                valor_pitch_float = float(att_pitch_str)
                angulo_rotacion_pygame = -valor_pitch_float 
                imagen_pitch_rotada_grande = pygame.transform.rotate(pitch_image_base_grande, angulo_rotacion_pygame)
                diametro_claraboya = 2 * radio_circulo_img
                claraboya_surface = pygame.Surface((diametro_claraboya, diametro_claraboya), pygame.SRCALPHA)
                claraboya_surface.fill((0,0,0,0)) 
                offset_x = (diametro_claraboya - imagen_pitch_rotada_grande.get_width()) // 2
                offset_y = (diametro_claraboya - imagen_pitch_rotada_grande.get_height()) // 2
                claraboya_surface.blit(imagen_pitch_rotada_grande, (offset_x, offset_y))
                mask = pygame.Surface((diametro_claraboya, diametro_claraboya), pygame.SRCALPHA); mask.fill((0,0,0,0))
                pygame.draw.circle(mask, (255, 255, 255, 255), (radio_circulo_img, radio_circulo_img), radio_circulo_img)
                claraboya_surface.blit(mask, (0,0), special_flags=pygame.BLEND_RGBA_MULT)
                rect_claraboya_final = claraboya_surface.get_rect(center=(centro_x_circulo1, centro_y_circulos))
                screen.blit(claraboya_surface, rect_claraboya_final)
            except ValueError: pass 
        
        pygame.draw.circle(screen, BLANCO, (centro_x_circulo1, centro_y_circulos), radio_circulo_img, 2)

        for key, (angle_deg, etiqueta_str) in ANGULOS_MARCAS_ETIQUETAS_DEF.items(): 
            angle_rad = math.radians(angle_deg)
            x_inicio_marca = centro_x_circulo1 + RADIO_INICIO_MARCAS * math.cos(angle_rad)
            y_inicio_marca = centro_y_circulos + RADIO_INICIO_MARCAS * math.sin(angle_rad) 
            x_fin_marca = centro_x_circulo1 + RADIO_FIN_MARCAS * math.cos(angle_rad)
            y_fin_marca = centro_y_circulos + RADIO_FIN_MARCAS * math.sin(angle_rad)
            pygame.draw.line(screen, COLOR_MARCA_GRADO, (x_inicio_marca, y_inicio_marca), (x_fin_marca, y_fin_marca), GROSOR_MARCA_GRADO)
            etiqueta_surf = font.render(etiqueta_str, True, COLOR_ETIQUETA_GRADO) 
            x_texto_etiqueta = centro_x_circulo1 + RADIO_POSICION_TEXTO_ETIQUETA * math.cos(angle_rad)
            y_texto_etiqueta = centro_y_circulos + RADIO_POSICION_TEXTO_ETIQUETA * math.sin(angle_rad)
            etiqueta_rect = etiqueta_surf.get_rect(center=(int(x_texto_etiqueta), int(y_texto_etiqueta)))
            screen.blit(etiqueta_surf, etiqueta_rect)

        if att_pitch_str != "N/A":
            try:
                valor_pitch_float = float(att_pitch_str)
                pitch_valor_surf = font_circulos_textos.render(f"{valor_pitch_float:+.1f}°", True, BLANCO) 
                y_pos_texto_pitch = centro_y_circulos + radio_circulo_img * 0.0282
                pitch_valor_rect = pitch_valor_surf.get_rect(center=(centro_x_circulo1, y_pos_texto_pitch))
                screen.blit(pitch_valor_surf, pitch_valor_rect)
                pos_flecha_pitch_x = pitch_valor_rect.left - OFFSET_FLECHA_TEXTO - (LONGITUD_FLECHA_DIR // 2)
                pos_flecha_pitch_y_centro = pitch_valor_rect.centery
                if valor_pitch_float > 0.1: 
                    pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), 2)
                    pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x - ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), 2)
                    pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x + ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), 2)
                elif valor_pitch_float < -0.1: 
                    pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x, pos_flecha_pitch_y_centro - LONGITUD_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), 2)
                    pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x - ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), 2)
                    pygame.draw.line(screen, BLANCO, (pos_flecha_pitch_x + ANCHO_FLECHA_DIR // 2, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2), (pos_flecha_pitch_x, pos_flecha_pitch_y_centro + LONGITUD_FLECHA_DIR // 2), 2)
            except ValueError: pass 

        if roll_image_base_grande: 
            try:
                valor_roll_float = float(att_roll_str)
                angulo_rotacion_pygame_roll = -valor_roll_float 
                imagen_roll_rotada_grande = pygame.transform.rotate(roll_image_base_grande, angulo_rotacion_pygame_roll)
                diametro_claraboya_roll = 2 * radio_circulo_img 
                claraboya_surface_roll = pygame.Surface((diametro_claraboya_roll, diametro_claraboya_roll), pygame.SRCALPHA)
                claraboya_surface_roll.fill((0,0,0,0)) 
                offset_x_roll = (diametro_claraboya_roll - imagen_roll_rotada_grande.get_width()) // 2
                offset_y_roll = (diametro_claraboya_roll - imagen_roll_rotada_grande.get_height()) // 2
                claraboya_surface_roll.blit(imagen_roll_rotada_grande, (offset_x_roll, offset_y_roll))
                mask_roll = pygame.Surface((diametro_claraboya_roll, diametro_claraboya_roll), pygame.SRCALPHA); mask_roll.fill((0,0,0,0))
                pygame.draw.circle(mask_roll, (255, 255, 255, 255), (radio_circulo_img, radio_circulo_img), radio_circulo_img)
                claraboya_surface_roll.blit(mask_roll, (0,0), special_flags=pygame.BLEND_RGBA_MULT)
                rect_claraboya_final_roll = claraboya_surface_roll.get_rect(center=(centro_x_circulo2, centro_y_circulos))
                screen.blit(claraboya_surface_roll, rect_claraboya_final_roll)
            except ValueError: pass 
        
        pygame.draw.circle(screen, BLANCO, (centro_x_circulo2, centro_y_circulos), radio_circulo_img, 2)

        for key, (angle_deg, etiqueta_str) in ANGULOS_MARCAS_ETIQUETAS_DEF.items(): 
            angle_rad = math.radians(angle_deg)
            x_inicio_marca_roll = centro_x_circulo2 + RADIO_INICIO_MARCAS * math.cos(angle_rad)
            y_inicio_marca_roll = centro_y_circulos + RADIO_INICIO_MARCAS * math.sin(angle_rad) 
            x_fin_marca_roll = centro_x_circulo2 + RADIO_FIN_MARCAS * math.cos(angle_rad)
            y_fin_marca_roll = centro_y_circulos + RADIO_FIN_MARCAS * math.sin(angle_rad)
            pygame.draw.line(screen, COLOR_MARCA_GRADO, (x_inicio_marca_roll, y_inicio_marca_roll), (x_fin_marca_roll, y_fin_marca_roll), GROSOR_MARCA_GRADO)
            etiqueta_surf_roll = font.render(etiqueta_str, True, COLOR_ETIQUETA_GRADO) 
            x_texto_etiqueta_roll = centro_x_circulo2 + RADIO_POSICION_TEXTO_ETIQUETA * math.cos(angle_rad)
            y_texto_etiqueta_roll = centro_y_circulos + RADIO_POSICION_TEXTO_ETIQUETA * math.sin(angle_rad)
            etiqueta_rect_roll = etiqueta_surf_roll.get_rect(center=(int(x_texto_etiqueta_roll), int(y_texto_etiqueta_roll)))
            screen.blit(etiqueta_surf_roll, etiqueta_rect_roll)

        if att_roll_str != "N/A":
            try:
                valor_roll_float = float(att_roll_str)
                roll_valor_surf = font_circulos_textos.render(f"{valor_roll_float:+.1f}°", True, BLANCO) 
                y_pos_texto_roll = centro_y_circulos + radio_circulo_img * 0.0282
                roll_valor_rect = roll_valor_surf.get_rect(center=(centro_x_circulo2, y_pos_texto_roll))
                screen.blit(roll_valor_surf, roll_valor_rect)
                letra_roll_str = ""
                if valor_roll_float > 0.1: letra_roll_str = "S"
                elif valor_roll_float < -0.1: letra_roll_str = "P"
                if letra_roll_str:
                    letra_roll_surf = font_circulos_textos.render(letra_roll_str, True, COLOR_LETRA_ROLL) 
                    letra_roll_rect = letra_roll_surf.get_rect(midtop=(roll_valor_rect.centerx, roll_valor_rect.bottom + OFFSET_LETRA_ROLL_Y))
                    screen.blit(letra_roll_surf, letra_roll_rect)
                pos_flecha_roll_y_centro = roll_valor_rect.centery
                if valor_roll_float > 0.1: 
                    pos_flecha_roll_x = roll_valor_rect.right + OFFSET_FLECHA_TEXTO + (LONGITUD_FLECHA_DIR // 2)
                    pygame.draw.line(screen, VERDE, (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                    pygame.draw.line(screen, VERDE, (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro - ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                    pygame.draw.line(screen, VERDE, (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2 - ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro + ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                elif valor_roll_float < -0.1: 
                    pos_flecha_roll_x = roll_valor_rect.left - OFFSET_FLECHA_TEXTO - (LONGITUD_FLECHA_DIR // 2)
                    pygame.draw.line(screen, ROJO, (pos_flecha_roll_x + LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                    pygame.draw.line(screen, ROJO, (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro - ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
                    pygame.draw.line(screen, ROJO, (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2 + ANCHO_FLECHA_DIR // 2, pos_flecha_roll_y_centro + ANCHO_FLECHA_DIR // 2), (pos_flecha_roll_x - LONGITUD_FLECHA_DIR // 2, pos_flecha_roll_y_centro), 2)
            except ValueError: pass

        espacio_entre_cajas_vertical = 10 
        ancho_cajas_datos = 280 
        x_inicio_cajas_datos = area_izquierda_rect.right + 10 
        altura_caja_latlon = 120 
        y_caja_latlon = ALTURA_BARRA_HERRAMIENTAS + espacio_entre_cajas_vertical
        dim_caja_gll = [x_inicio_cajas_datos, y_caja_latlon, ancho_cajas_datos, altura_caja_latlon]
        altura_caja_rumbo_vel = 120 
        y_caja_rumbo_vel = y_caja_latlon + altura_caja_latlon + espacio_entre_cajas_vertical
        dim_caja_rumbo_vel = [x_inicio_cajas_datos, y_caja_rumbo_vel, ancho_cajas_datos, altura_caja_rumbo_vel]
        altura_caja_cabeceo = 120
        y_caja_cabeceo = y_caja_rumbo_vel + altura_caja_rumbo_vel + espacio_entre_cajas_vertical
        dim_caja_att = [x_inicio_cajas_datos, y_caja_cabeceo, ancho_cajas_datos, altura_caja_cabeceo]
        
        pygame.draw.rect(screen, COLOR_CAJA_DATOS_FONDO, dim_caja_gll)
        pygame.draw.rect(screen, COLOR_CAJA_DATOS_BORDE, dim_caja_gll, 1) 
        pygame.draw.rect(screen, COLOR_CAJA_DATOS_FONDO, dim_caja_rumbo_vel)
        pygame.draw.rect(screen, COLOR_CAJA_DATOS_BORDE, dim_caja_rumbo_vel, 1)
        pygame.draw.rect(screen, COLOR_CAJA_DATOS_FONDO, dim_caja_att)
        pygame.draw.rect(screen, COLOR_CAJA_DATOS_BORDE, dim_caja_att, 1)

        text_surface_titulo_latlon = font.render(texto_latitud_lon_titulo, True, COLOR_CAJA_DATOS_TEXTO) 
        text_rect_titulo_latlon = text_surface_titulo_latlon.get_rect(centerx = dim_caja_gll[0] + dim_caja_gll[2] // 2, top = dim_caja_gll[1] + 5 )
        screen.blit(text_surface_titulo_latlon, text_rect_titulo_latlon)
        text_surface_lat_data = font_datos_grandes.render(latitude_str, True, COLOR_CAJA_DATOS_TEXTO)
        text_rect_lat_data = text_surface_lat_data.get_rect(centerx = dim_caja_gll[0] + dim_caja_gll[2] // 2, top = text_rect_titulo_latlon.bottom + 2)
        screen.blit(text_surface_lat_data, text_rect_lat_data)
        text_surface_lon_data = font_datos_grandes.render(longitude_str, True, COLOR_CAJA_DATOS_TEXTO)
        text_rect_lon_data = text_surface_lon_data.get_rect(centerx = dim_caja_gll[0] + dim_caja_gll[2] // 2, top = text_rect_lat_data.bottom + 2)
        screen.blit(text_surface_lon_data, text_rect_lon_data)

        padding_horizontal_caja = 15 
        y_pos_rumbo_vel = dim_caja_rumbo_vel[1] + 10 
        rumbo_etiqueta_surf = font.render("RUMBO :", True, COLOR_CAJA_DATOS_TEXTO)
        rumbo_etiqueta_rect = rumbo_etiqueta_surf.get_rect(left=dim_caja_rumbo_vel[0] + padding_horizontal_caja, top=y_pos_rumbo_vel)
        rumbo_valor_surf = font_datos_grandes.render(heading_str, True, COLOR_CAJA_DATOS_TEXTO)
        rumbo_valor_rect = rumbo_valor_surf.get_rect(left=rumbo_etiqueta_rect.right + 5, centery=rumbo_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2 ) 
        screen.blit(rumbo_etiqueta_surf, rumbo_etiqueta_rect); screen.blit(rumbo_valor_surf, rumbo_valor_rect)
        y_pos_velocidad = rumbo_etiqueta_rect.top + font_datos_grandes.get_linesize() + 5 
        vel_etiqueta_surf = font.render("Velocidad :", True, COLOR_CAJA_DATOS_TEXTO)
        vel_etiqueta_rect = vel_etiqueta_surf.get_rect(left=dim_caja_rumbo_vel[0] + padding_horizontal_caja, top=y_pos_velocidad)
        vel_valor_surf = font_datos_grandes.render(speed_str, True, COLOR_CAJA_DATOS_TEXTO)
        vel_valor_rect = vel_valor_surf.get_rect(left=vel_etiqueta_rect.right + 5, centery=vel_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2)
        screen.blit(vel_etiqueta_surf, vel_etiqueta_rect); screen.blit(vel_valor_surf, vel_valor_rect)

        text_surface_titulo_cabeceo = font.render(texto_actitud_titulo, True, COLOR_CAJA_DATOS_TEXTO) 
        text_rect_titulo_cabeceo = text_surface_titulo_cabeceo.get_rect(centerx = dim_caja_att[0] + dim_caja_att[2] // 2, top = dim_caja_att[1] + 10)
        screen.blit(text_surface_titulo_cabeceo, text_rect_titulo_cabeceo)
        current_y_att = text_rect_titulo_cabeceo.bottom + 10
        pitch_etiqueta_str = "PITCH :"
        pitch_valor_str = "N/A"
        if att_pitch_str != "N/A":
            try: pitch_valor_str = f"{float(att_pitch_str):+.0f}°"
            except ValueError: pass 
        pitch_etiqueta_surf = font.render(pitch_etiqueta_str, True, COLOR_CAJA_DATOS_TEXTO)
        pitch_etiqueta_rect = pitch_etiqueta_surf.get_rect(left=dim_caja_att[0] + padding_horizontal_caja, top=current_y_att)
        pitch_valor_surf = font_datos_grandes.render(pitch_valor_str, True, COLOR_CAJA_DATOS_TEXTO)
        pitch_valor_rect = pitch_valor_surf.get_rect(left=pitch_etiqueta_rect.right + 5, centery=pitch_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2)
        screen.blit(pitch_etiqueta_surf, pitch_etiqueta_rect); screen.blit(pitch_valor_surf, pitch_valor_rect)
        current_y_att += font_datos_grandes.get_linesize() + 5 
        roll_etiqueta_str = "ROLL : " 
        roll_valor_display_str = "N/A"; roll_direccion_str = ""     
        if att_roll_str != "N/A":
            try:
                roll_val = float(att_roll_str)
                roll_valor_display_str = f"{roll_val:+.0f}°" 
                if roll_val > 0.1: roll_direccion_str = "ESTRIBOR"
                elif roll_val < -0.1: roll_direccion_str = "BABOR"
            except ValueError: pass 
        roll_etiqueta_surf = font.render(roll_etiqueta_str, True, COLOR_CAJA_DATOS_TEXTO)
        roll_etiqueta_rect = roll_etiqueta_surf.get_rect(left=dim_caja_att[0] + padding_horizontal_caja, top=current_y_att)
        roll_valor_surf = font_datos_grandes.render(roll_valor_display_str, True, COLOR_CAJA_DATOS_TEXTO)
        roll_valor_rect = roll_valor_surf.get_rect(left=roll_etiqueta_rect.right + 5, centery=roll_etiqueta_rect.centery + (font_datos_grandes.get_linesize() - font.get_linesize()) // 2 + 2)
        screen.blit(roll_etiqueta_surf, roll_etiqueta_rect)
        screen.blit(roll_valor_surf, roll_valor_rect) 
        if roll_direccion_str: 
            roll_direccion_surf = font.render(roll_direccion_str, True, COLOR_CAJA_DATOS_TEXTO)
            roll_direccion_rect = roll_direccion_surf.get_rect(left=roll_valor_rect.right + 5, centery=roll_etiqueta_rect.centery) 
            screen.blit(roll_direccion_surf, roll_direccion_rect)
        
        if serial_port_available and ser and ser.is_open:
            ahora = pygame.time.get_ticks()
            if ahora - ultima_vez_datos_recibidos > UMBRAL_SIN_DATOS_MS:
                mensaje_no_datos = "NO HAY DATOS NMEA"
                texto_no_datos_surf = font.render(mensaje_no_datos, True, ROJO)
                rect_texto_no_datos = texto_no_datos_surf.get_rect(center=area_izquierda_rect.center)
                screen.blit(texto_no_datos_surf, rect_texto_no_datos)
        elif not serial_port_available: 
            ahora = pygame.time.get_ticks()
            mensaje_desconexion = "Puerto NMEA desconectado."
            texto_desconexion_surf = font.render(mensaje_desconexion, True, ROJO)
            rect_texto_desconexion = texto_desconexion_surf.get_rect(center=area_izquierda_rect.center)
            screen.blit(texto_desconexion_surf, rect_texto_desconexion)
 
    pygame.display.flip()
    reloj.tick(60)

if serial_port_available and ser is not None: 
    ser.close() 
pygame.quit()

